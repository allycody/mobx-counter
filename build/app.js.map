{"version":3,"sources":["webpack:///app.js","webpack:///webpack/bootstrap 308800d3c7c031a6d090","webpack:///./src/app/app.js","webpack:///./~/mobx/lib/mobx.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_mobx","CounterStore","observable","counter","render","document","getElementById","innerHTML","autorun","window","plusClick","minusClick","global","arg1","arg2","arg3","name","view","scope","getNextId","assertUnwrapped","invariant","length","bind","reaction","Reaction","this","track","schedule","getDisposer","when","arg4","predicate","effect","disposeImmediately","disposer","prevUntracked","untrackedStart","untrackedEnd","autorunUntil","deprecated","apply","arguments","autorunAsync","func","delay","isScheduled","r","setTimeout","isDisposed","arg5","arg6","reactionRunner","changed","v","unwrappedExpression","valueDidChange","compareStructural","nextValue","firstTime","fireImmediately","expression","_a","getValueModeFromValue","ValueMode","Reference","valueMode","Structure","action","undefined","computed","targetOrExpr","keyOrScope","baseDescriptor","options","computedExpr","set","computedDecorator","expr","Recursive","mode","value","ComputedValue","throwingComputedValueSetter","Error","createTransformer","transformer","onCleanup","objectCache","resetId","globalState","Transformer","_super","sourceIdentifier","sourceObject","__extends","prototype","onBecomeUnobserved","lastValue","object","identifier","getMemoizationId","reactiveTransformer","get","tid","$transformId","Object","defineProperty","configurable","writable","enumerable","isComputingDerivation","console","warn","extendObservable","target","properties","_i","ObservableMap","forEach","propSet","extendObservableHelper","adm","asObservableObject","key","hasOwnProperty","isPropertyConfigurable","setObservableObjectInstanceProperty","getDependencyTree","thing","property","nodeToDependencyTree","getAtom","node","result","observing","dependencies","unique","map","getObserverTree","nodeToObserverTree","observers","intercept","propOrHandler","handler","interceptProperty","interceptInterceptable","isPlainObject","isObservableObject","getAdministration","isObservable","ObservableArray","o","$mobx","values","Atom","observableDecorator","assertPropertyConfigurable","decoratorImpl","sourceType","ValueType","getTypeOfValue","Array","PlainObject","makeChildObservable","ComplexObject","ObservableValue","ComplexFunction","ViewFunction","isArray","observe","propOrCb","cbOrFire","observeObservableProperty","observeObservable","listener","toJS","source","detectCycles","__alreadySeen","cache","push","i","l","res","toAdd","res_1","toJSON","log","msg","whyRun","prop","derivationStack","actionImplementation","actionDecorator","isAction","isMobxAction","runInAction","actionName","fn","executeWrapped","args","ds","startTime","notifySpy","isSpyEnabled","Date","now","flattendArgs","spyReportStart","type","transactionStart","prevAllowStateChanges","allowStateChangesStart","allowStateChangesEnd","transactionEnd","spyReportEnd","time","useStrict","strict","strictMode","allowStateChanges","prev","propagateAtomReady","atom","isDirty","propagateReadiness","checkIfStateModificationsAreAllowed","notifyDependencyStale","derivation","dependencyStaleCount","propagateStaleness","notifyDependencyReady","dependencyDidChange","dependencyChangeCount","onDependenciesReady","trackDerivedFunction","f","hasException","prevObserving","prevTracking","isTracking","bindDependencies","message","spyReport","error","resetGlobalState","quickDiff","added","removed","dependency","findCycle","addObserver","removeObserver","needle","obs","untracked","registerGlobals","defaultGlobals","MobXGlobals","persistentKeys","indexOf","onBecomeObserved","idx","splice","reportObserved","deps","depslength","os","slice","staleObservers","concat","valueDidActuallyChange","runReactions","isRunningReactions","inTransaction","allReactions","pendingReactions","iterations","MAX_REACTION_ITERATIONS","toString","remainingReactions","runReaction","spyEnabled","event","listeners","spyListeners","change","objectAssign","END_EVENT","spy","once","trackTransitions","onReport","transaction","thisArg","report","changedAtoms","hasInterceptors","interceptable","interceptors","registerInterceptor","interceptChange","prevU","hasListeners","listenable","changeListeners","registerListener","notifyListeners","asReference","AsReference","asStructure","AsStructure","asFlat","AsFlat","asMap","data","modifierFunc","defaultMode","Flat","getValueModeFromModifierFunc","parentMode","childMode","createObservableArray","isExtensible","createArrayBufferItem","index","createArraySetter","createArrayGetter","newValue","oldValue","array","makeReactiveArrayItem","deepEquals","notifyArrayChildUpdate","spliceWithArray","impl","reserveArrayBuffer","max","OBSERVABLE_ARRAY_BUFFER_SIZE","initialValues","fastArray","isObservableArray","valueModifier","isObservableMap","constructor","ObservableObjectAdministration","propName","defineObservableProperty","asInstanceProperty","isComputed","setPropertyValue","notifyPropertyAddition","instance","prepareNewValue","UNCHANGED","notify","setNewValue","runLazyInitializers","_keys","observable_1","_data","_hasMap","getDebugName","observable_2","named","createClassPropertyDecorator","onInitialize","allowCustomArguments","classPropertyDecorator","descriptor","customArgs","quacksLikeADecorator","__mobxLazyInitializers","value_1","initializer_1","initializer","__mobxDidRunLazyInitializers","__mobxInitializedProps","typescriptInitializeProperty","outerArgs","mobxGuid","check","deprecatedMessages","invoked","list","item","joinStrings","things","limit","separator","sliced","join","getPrototypeOf","makeNonEnumerable","props","getOwnPropertyDescriptor","getEnumerableKeys","obj","a","b","aIsArray","current","base","currentIndex","currentSearch","currentLength","currentExhausted","baseIndex","baseSearch","baseLength","isSearching","baseExhausted","d","__","create","extras","_","decoratorArgs","originalDescriptor","baseValue","prevA","wrappedAction","noop","reportChanged","reportStale","reportReady","RunReason","isLazy","isComputing","peek","trackAndCompute","_this","prevValue","dep","runReason","INVALIDATED","REQUIRED","PEEK","NOT_RUNNING","requiredBy","runReasonTexts","version","__mobservableTrackingStack","__mobservableViewStack","__mobxGlobal","onInvalidate","EMPTY_ARRAY","_isScheduled","_isTrackPending","_isRunning","dispose","StubArray","ObservableArrayAdministration","owned","lastKnownLength","addedCount","removedCount","getArrayLength","setArrayLength","newLength","updateArrayLength","oldLength","delta","deleteCount","newItems","Math","min","lengthDelta","notifyArraySplice","clear","replace","find","fromIndex","items","pop","shift","unshift","reverse","clone","sort","compareFn","remove","toLocaleString","funcName","baseFunc","ObservableMapMarker","initialData","valueModeFunc","_valueMode","merge","_has","has","isValidKey","_updateHasMapEntry","assertValidKey","hasKey","_updateValue","_addValue","entry","keys","entries","callback","other","toJs","hasUnreportedChange","childmode","unwrappedValue","SimpleEventEmitter","emit","on","subscription","freeze"],"mappings":"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","file":"app.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _mobx = __webpack_require__(2);\n\t\n\tvar CounterStore = (0, _mobx.observable)({\n\t  counter: 0\n\t});\n\t\n\tvar render = function render() {\n\t  document.getElementById('counter').innerHTML = CounterStore.counter;\n\t};\n\t\n\t(0, _mobx.autorun)(render);\n\t\n\twindow.plusClick = function () {\n\t  CounterStore.counter++;\n\t};\n\t\n\twindow.minusClick = function () {\n\t  CounterStore.counter--;\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tregisterGlobals();\n\texports.extras = {\n\t    allowStateChanges: allowStateChanges,\n\t    getAtom: getAtom,\n\t    getDebugName: getDebugName,\n\t    getDependencyTree: getDependencyTree,\n\t    getObserverTree: getObserverTree,\n\t    isComputingDerivation: isComputingDerivation,\n\t    isSpyEnabled: isSpyEnabled,\n\t    resetGlobalState: resetGlobalState,\n\t    spyReport: spyReport,\n\t    spyReportEnd: spyReportEnd,\n\t    spyReportStart: spyReportStart,\n\t    trackTransitions: trackTransitions\n\t};\n\texports._ = {\n\t    getAdministration: getAdministration,\n\t    quickDiff: quickDiff,\n\t    resetGlobalState: resetGlobalState\n\t};\n\tfunction autorun(arg1, arg2, arg3) {\n\t    var name, view, scope;\n\t    if (typeof arg1 === \"string\") {\n\t        name = arg1;\n\t        view = arg2;\n\t        scope = arg3;\n\t    }\n\t    else if (typeof arg1 === \"function\") {\n\t        name = arg1.name || (\"Autorun@\" + getNextId());\n\t        view = arg1;\n\t        scope = arg2;\n\t    }\n\t    assertUnwrapped(view, \"autorun methods cannot have modifiers\");\n\t    invariant(typeof view === \"function\", \"autorun expects a function\");\n\t    invariant(view.length === 0, \"autorun expects a function without arguments\");\n\t    if (scope)\n\t        view = view.bind(scope);\n\t    var reaction = new Reaction(name, function () {\n\t        this.track(view);\n\t    });\n\t    reaction.schedule();\n\t    return reaction.getDisposer();\n\t}\n\texports.autorun = autorun;\n\tfunction when(arg1, arg2, arg3, arg4) {\n\t    var name, predicate, effect, scope;\n\t    if (typeof arg1 === \"string\") {\n\t        name = arg1;\n\t        predicate = arg2;\n\t        effect = arg3;\n\t        scope = arg4;\n\t    }\n\t    else if (typeof arg1 === \"function\") {\n\t        name = (\"When@\" + getNextId());\n\t        predicate = arg1;\n\t        effect = arg2;\n\t        scope = arg3;\n\t    }\n\t    var disposeImmediately = false;\n\t    var disposer = autorun(name, function () {\n\t        if (predicate.call(scope)) {\n\t            if (disposer)\n\t                disposer();\n\t            else\n\t                disposeImmediately = true;\n\t            var prevUntracked = untrackedStart();\n\t            effect.call(scope);\n\t            untrackedEnd(prevUntracked);\n\t        }\n\t    });\n\t    if (disposeImmediately)\n\t        disposer();\n\t    return disposer;\n\t}\n\texports.when = when;\n\tfunction autorunUntil(predicate, effect, scope) {\n\t    deprecated(\"`autorunUntil` is deprecated, please use `when`.\");\n\t    return when.apply(null, arguments);\n\t}\n\texports.autorunUntil = autorunUntil;\n\tfunction autorunAsync(arg1, arg2, arg3, arg4) {\n\t    var name, func, delay, scope;\n\t    if (typeof arg1 === \"string\") {\n\t        name = arg1;\n\t        func = arg2;\n\t        delay = arg3;\n\t        scope = arg4;\n\t    }\n\t    else if (typeof arg1 === \"function\") {\n\t        name = arg1.name || (\"AutorunAsync@\" + getNextId());\n\t        func = arg1;\n\t        delay = arg2;\n\t        scope = arg3;\n\t    }\n\t    if (delay === void 0)\n\t        delay = 1;\n\t    if (scope)\n\t        func = func.bind(scope);\n\t    var isScheduled = false;\n\t    var r = new Reaction(name, function () {\n\t        if (!isScheduled) {\n\t            isScheduled = true;\n\t            setTimeout(function () {\n\t                isScheduled = false;\n\t                if (!r.isDisposed)\n\t                    r.track(func);\n\t            }, delay);\n\t        }\n\t    });\n\t    r.schedule();\n\t    return r.getDisposer();\n\t}\n\texports.autorunAsync = autorunAsync;\n\tfunction reaction(arg1, arg2, arg3, arg4, arg5, arg6) {\n\t    var name, expression, effect, fireImmediately, delay, scope;\n\t    if (typeof arg1 === \"string\") {\n\t        name = arg1;\n\t        expression = arg2;\n\t        effect = arg3;\n\t        fireImmediately = arg4;\n\t        delay = arg5;\n\t        scope = arg6;\n\t    }\n\t    else {\n\t        name = arg1.name || arg2.name || (\"Reaction@\" + getNextId());\n\t        expression = arg1;\n\t        effect = arg2;\n\t        fireImmediately = arg3;\n\t        delay = arg4;\n\t        scope = arg5;\n\t    }\n\t    if (fireImmediately === void 0)\n\t        fireImmediately = false;\n\t    if (delay === void 0)\n\t        delay = 0;\n\t    var _a = getValueModeFromValue(expression, ValueMode.Reference), valueMode = _a[0], unwrappedExpression = _a[1];\n\t    var compareStructural = valueMode === ValueMode.Structure;\n\t    if (scope) {\n\t        unwrappedExpression = unwrappedExpression.bind(scope);\n\t        effect = action(name, effect.bind(scope));\n\t    }\n\t    var firstTime = true;\n\t    var isScheduled = false;\n\t    var nextValue = undefined;\n\t    function reactionRunner() {\n\t        if (r.isDisposed)\n\t            return;\n\t        var changed = false;\n\t        r.track(function () {\n\t            var v = unwrappedExpression();\n\t            changed = valueDidChange(compareStructural, nextValue, v);\n\t            nextValue = v;\n\t        });\n\t        if (firstTime && fireImmediately)\n\t            effect(nextValue);\n\t        if (!firstTime && changed === true)\n\t            effect(nextValue);\n\t        if (firstTime)\n\t            firstTime = false;\n\t    }\n\t    var r = new Reaction(name, function () {\n\t        if (delay < 1) {\n\t            reactionRunner();\n\t        }\n\t        else if (!isScheduled) {\n\t            isScheduled = true;\n\t            setTimeout(function () {\n\t                isScheduled = false;\n\t                reactionRunner();\n\t            }, delay);\n\t        }\n\t    });\n\t    r.schedule();\n\t    return r.getDisposer();\n\t}\n\texports.reaction = reaction;\n\tvar computedDecorator = createClassPropertyDecorator(function (target, name, _, decoratorArgs, originalDescriptor) {\n\t    var baseValue = originalDescriptor.get;\n\t    invariant(typeof baseValue === \"function\", \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\");\n\t    var compareStructural = false;\n\t    if (decoratorArgs && decoratorArgs.length === 1 && decoratorArgs[0].asStructure === true)\n\t        compareStructural = true;\n\t    var adm = asObservableObject(target, undefined, ValueMode.Recursive);\n\t    defineObservableProperty(adm, name, compareStructural ? asStructure(baseValue) : baseValue, false);\n\t}, function (name) {\n\t    return this.$mobx.values[name].get();\n\t}, throwingComputedValueSetter, false, true);\n\tfunction computed(targetOrExpr, keyOrScope, baseDescriptor, options) {\n\t    if (arguments.length < 3 && typeof targetOrExpr === \"function\")\n\t        return computedExpr(targetOrExpr, keyOrScope);\n\t    invariant(!baseDescriptor || !baseDescriptor.set, \"@observable properties cannot have a setter: \" + keyOrScope);\n\t    return computedDecorator.apply(null, arguments);\n\t}\n\texports.computed = computed;\n\tfunction computedExpr(expr, scope) {\n\t    var _a = getValueModeFromValue(expr, ValueMode.Recursive), mode = _a[0], value = _a[1];\n\t    return new ComputedValue(value, scope, mode === ValueMode.Structure, value.name);\n\t}\n\tfunction throwingComputedValueSetter() {\n\t    throw new Error(\"[ComputedValue] It is not allowed to assign new values to computed properties.\");\n\t}\n\tfunction createTransformer(transformer, onCleanup) {\n\t    invariant(typeof transformer === \"function\" && transformer.length === 1, \"createTransformer expects a function that accepts one argument\");\n\t    var objectCache = {};\n\t    var resetId = globalState.resetId;\n\t    var Transformer = (function (_super) {\n\t        __extends(Transformer, _super);\n\t        function Transformer(sourceIdentifier, sourceObject) {\n\t            _super.call(this, function () { return transformer(sourceObject); }, null, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier);\n\t            this.sourceIdentifier = sourceIdentifier;\n\t            this.sourceObject = sourceObject;\n\t        }\n\t        Transformer.prototype.onBecomeUnobserved = function () {\n\t            var lastValue = this.value;\n\t            _super.prototype.onBecomeUnobserved.call(this);\n\t            delete objectCache[this.sourceIdentifier];\n\t            if (onCleanup)\n\t                onCleanup(lastValue, this.sourceObject);\n\t        };\n\t        return Transformer;\n\t    }(ComputedValue));\n\t    return function (object) {\n\t        if (resetId !== globalState.resetId) {\n\t            objectCache = {};\n\t            resetId = globalState.resetId;\n\t        }\n\t        var identifier = getMemoizationId(object);\n\t        var reactiveTransformer = objectCache[identifier];\n\t        if (reactiveTransformer)\n\t            return reactiveTransformer.get();\n\t        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n\t        return reactiveTransformer.get();\n\t    };\n\t}\n\texports.createTransformer = createTransformer;\n\tfunction getMemoizationId(object) {\n\t    if (object === null || typeof object !== \"object\")\n\t        throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n\t    var tid = object.$transformId;\n\t    if (tid === undefined) {\n\t        tid = getNextId();\n\t        Object.defineProperty(object, \"$transformId\", {\n\t            configurable: true,\n\t            writable: true,\n\t            enumerable: false,\n\t            value: tid\n\t        });\n\t    }\n\t    return tid;\n\t}\n\tfunction expr(expr, scope) {\n\t    if (!isComputingDerivation())\n\t        console.warn(\"[mobx.expr] 'expr' should only be used inside other reactive functions.\");\n\t    return computed(expr, scope).get();\n\t}\n\texports.expr = expr;\n\tfunction extendObservable(target) {\n\t    var properties = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        properties[_i - 1] = arguments[_i];\n\t    }\n\t    invariant(arguments.length >= 2, \"extendObservable expected 2 or more arguments\");\n\t    invariant(typeof target === \"object\", \"extendObservable expects an object as first argument\");\n\t    invariant(!(target instanceof ObservableMap), \"extendObservable should not be used on maps, use map.merge instead\");\n\t    properties.forEach(function (propSet) {\n\t        invariant(typeof propSet === \"object\", \"all arguments of extendObservable should be objects\");\n\t        extendObservableHelper(target, propSet, ValueMode.Recursive, null);\n\t    });\n\t    return target;\n\t}\n\texports.extendObservable = extendObservable;\n\tfunction extendObservableHelper(target, properties, mode, name) {\n\t    var adm = asObservableObject(target, name, mode);\n\t    for (var key in properties)\n\t        if (properties.hasOwnProperty(key)) {\n\t            if (target === properties && !isPropertyConfigurable(target, key))\n\t                continue;\n\t            setObservableObjectInstanceProperty(adm, key, properties[key]);\n\t        }\n\t    return target;\n\t}\n\tfunction getDependencyTree(thing, property) {\n\t    return nodeToDependencyTree(getAtom(thing, property));\n\t}\n\tfunction nodeToDependencyTree(node) {\n\t    var result = {\n\t        name: node.name\n\t    };\n\t    if (node.observing && node.observing.length)\n\t        result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n\t    return result;\n\t}\n\tfunction getObserverTree(thing, property) {\n\t    return nodeToObserverTree(getAtom(thing, property));\n\t}\n\tfunction nodeToObserverTree(node) {\n\t    var result = {\n\t        name: node.name\n\t    };\n\t    if (node.observers && node.observers.length)\n\t        result.observers = unique(node.observers).map(nodeToObserverTree);\n\t    return result;\n\t}\n\tfunction intercept(thing, propOrHandler, handler) {\n\t    if (typeof handler === \"function\")\n\t        return interceptProperty(thing, propOrHandler, handler);\n\t    else\n\t        return interceptInterceptable(thing, propOrHandler);\n\t}\n\texports.intercept = intercept;\n\tfunction interceptInterceptable(thing, handler) {\n\t    if (isPlainObject(thing) && !isObservableObject(thing)) {\n\t        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n\t        return getAdministration(observable(thing)).intercept(handler);\n\t    }\n\t    return getAdministration(thing).intercept(handler);\n\t}\n\tfunction interceptProperty(thing, property, handler) {\n\t    if (isPlainObject(thing) && !isObservableObject(thing)) {\n\t        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n\t        extendObservable(thing, {\n\t            property: thing[property]\n\t        });\n\t        return interceptProperty(thing, property, handler);\n\t    }\n\t    return getAdministration(thing, property).intercept(handler);\n\t}\n\tfunction isObservable(value, property) {\n\t    if (value === null || value === undefined)\n\t        return false;\n\t    if (property !== undefined) {\n\t        if (value instanceof ObservableMap || value instanceof ObservableArray)\n\t            throw new Error(\"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\");\n\t        else if (isObservableObject(value)) {\n\t            var o = value.$mobx;\n\t            return o.values && !!o.values[property];\n\t        }\n\t        return false;\n\t    }\n\t    return !!value.$mobx || value instanceof Atom || value instanceof Reaction || value instanceof ComputedValue;\n\t}\n\texports.isObservable = isObservable;\n\tvar decoratorImpl = createClassPropertyDecorator(function (target, name, baseValue) {\n\t    var prevA = allowStateChangesStart(true);\n\t    if (typeof baseValue === \"function\")\n\t        baseValue = asReference(baseValue);\n\t    var adm = asObservableObject(target, undefined, ValueMode.Recursive);\n\t    defineObservableProperty(adm, name, baseValue, false);\n\t    allowStateChangesEnd(prevA);\n\t}, function (name) {\n\t    return this.$mobx.values[name].get();\n\t}, function (name, value) {\n\t    setPropertyValue(this, name, value);\n\t}, true, false);\n\tfunction observableDecorator(target, key, baseDescriptor) {\n\t    invariant(arguments.length >= 2 && arguments.length <= 3, \"Illegal decorator config\", key);\n\t    assertPropertyConfigurable(target, key);\n\t    invariant(!baseDescriptor || !baseDescriptor.get, \"@observable can not be used on getters, use @computed instead\");\n\t    return decoratorImpl.apply(null, arguments);\n\t}\n\tfunction observable(v, keyOrScope) {\n\t    if (v === void 0) { v = undefined; }\n\t    if (typeof arguments[1] === \"string\")\n\t        return observableDecorator.apply(null, arguments);\n\t    invariant(arguments.length < 3, \"observable expects zero, one or two arguments\");\n\t    if (isObservable(v))\n\t        return v;\n\t    var _a = getValueModeFromValue(v, ValueMode.Recursive), mode = _a[0], value = _a[1];\n\t    var sourceType = mode === ValueMode.Reference ? ValueType.Reference : getTypeOfValue(value);\n\t    switch (sourceType) {\n\t        case ValueType.Array:\n\t        case ValueType.PlainObject:\n\t            return makeChildObservable(value, mode);\n\t        case ValueType.Reference:\n\t        case ValueType.ComplexObject:\n\t            return new ObservableValue(value, mode);\n\t        case ValueType.ComplexFunction:\n\t            throw new Error(\"[mobx.observable] To be able to make a function reactive it should not have arguments. If you need an observable reference to a function, use `observable(asReference(f))`\");\n\t        case ValueType.ViewFunction:\n\t            deprecated(\"Use `computed(expr)` instead of `observable(expr)`\");\n\t            return computed(v, keyOrScope);\n\t    }\n\t    invariant(false, \"Illegal State\");\n\t}\n\texports.observable = observable;\n\tvar ValueType;\n\t(function (ValueType) {\n\t    ValueType[ValueType[\"Reference\"] = 0] = \"Reference\";\n\t    ValueType[ValueType[\"PlainObject\"] = 1] = \"PlainObject\";\n\t    ValueType[ValueType[\"ComplexObject\"] = 2] = \"ComplexObject\";\n\t    ValueType[ValueType[\"Array\"] = 3] = \"Array\";\n\t    ValueType[ValueType[\"ViewFunction\"] = 4] = \"ViewFunction\";\n\t    ValueType[ValueType[\"ComplexFunction\"] = 5] = \"ComplexFunction\";\n\t})(ValueType || (ValueType = {}));\n\tfunction getTypeOfValue(value) {\n\t    if (value === null || value === undefined)\n\t        return ValueType.Reference;\n\t    if (typeof value === \"function\")\n\t        return value.length ? ValueType.ComplexFunction : ValueType.ViewFunction;\n\t    if (Array.isArray(value) || value instanceof ObservableArray)\n\t        return ValueType.Array;\n\t    if (typeof value === \"object\")\n\t        return isPlainObject(value) ? ValueType.PlainObject : ValueType.ComplexObject;\n\t    return ValueType.Reference;\n\t}\n\tfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n\t    if (typeof cbOrFire === \"function\")\n\t        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);\n\t    else\n\t        return observeObservable(thing, propOrCb, cbOrFire);\n\t}\n\texports.observe = observe;\n\tfunction observeObservable(thing, listener, fireImmediately) {\n\t    if (isPlainObject(thing) && !isObservableObject(thing)) {\n\t        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n\t        return getAdministration(observable(thing)).observe(listener, fireImmediately);\n\t    }\n\t    return getAdministration(thing).observe(listener, fireImmediately);\n\t}\n\tfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n\t    if (isPlainObject(thing) && !isObservableObject(thing)) {\n\t        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n\t        extendObservable(thing, {\n\t            property: thing[property]\n\t        });\n\t        return observeObservableProperty(thing, property, listener, fireImmediately);\n\t    }\n\t    return getAdministration(thing, property).observe(listener, fireImmediately);\n\t}\n\tfunction toJS(source, detectCycles, __alreadySeen) {\n\t    if (detectCycles === void 0) { detectCycles = true; }\n\t    if (__alreadySeen === void 0) { __alreadySeen = null; }\n\t    function cache(value) {\n\t        if (detectCycles)\n\t            __alreadySeen.push([source, value]);\n\t        return value;\n\t    }\n\t    if (detectCycles && __alreadySeen === null)\n\t        __alreadySeen = [];\n\t    if (detectCycles && source !== null && typeof source === \"object\") {\n\t        for (var i = 0, l = __alreadySeen.length; i < l; i++)\n\t            if (__alreadySeen[i][0] === source)\n\t                return __alreadySeen[i][1];\n\t    }\n\t    if (!source)\n\t        return source;\n\t    if (Array.isArray(source) || source instanceof ObservableArray) {\n\t        var res = cache([]);\n\t        var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); });\n\t        res.length = toAdd.length;\n\t        for (var i = 0, l = toAdd.length; i < l; i++)\n\t            res[i] = toAdd[i];\n\t        return res;\n\t    }\n\t    if (source instanceof ObservableMap) {\n\t        var res_1 = cache({});\n\t        source.forEach(function (value, key) { return res_1[key] = toJS(value, detectCycles, __alreadySeen); });\n\t        return res_1;\n\t    }\n\t    if (isObservable(source) && source.$mobx instanceof ObservableValue)\n\t        return toJS(source(), detectCycles, __alreadySeen);\n\t    if (source instanceof ObservableValue)\n\t        return toJS(source.get(), detectCycles, __alreadySeen);\n\t    if (typeof source === \"object\") {\n\t        var res = cache({});\n\t        for (var key in source)\n\t            res[key] = toJS(source[key], detectCycles, __alreadySeen);\n\t        return res;\n\t    }\n\t    return source;\n\t}\n\texports.toJS = toJS;\n\tfunction toJSON(source, detectCycles, __alreadySeen) {\n\t    if (detectCycles === void 0) { detectCycles = true; }\n\t    if (__alreadySeen === void 0) { __alreadySeen = null; }\n\t    deprecated(\"toJSON is deprecated. Use toJS instead\");\n\t    return toJS.apply(null, arguments);\n\t}\n\texports.toJSON = toJSON;\n\tfunction log(msg) {\n\t    console.log(msg);\n\t    return msg;\n\t}\n\tfunction whyRun(thing, prop) {\n\t    switch (arguments.length) {\n\t        case 0:\n\t            thing = globalState.derivationStack[globalState.derivationStack.length - 1];\n\t            if (!thing)\n\t                return log(\"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested it's value.\");\n\t            break;\n\t        case 2:\n\t            thing = getAtom(thing, prop);\n\t            break;\n\t    }\n\t    thing = getAtom(thing);\n\t    if (thing instanceof ComputedValue)\n\t        return log(thing.whyRun());\n\t    else if (thing instanceof Reaction)\n\t        return log(thing.whyRun());\n\t    else\n\t        invariant(false, \"whyRun can only be used on reactions and computed values\");\n\t}\n\texports.whyRun = whyRun;\n\tvar actionDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n\t    var actionName = (args && args.length === 1) ? args[0] : (value.name || key || \"<unnamed action>\");\n\t    var wrappedAction = action(actionName, value);\n\t    if (originalDescriptor && originalDescriptor.value && target.constructor && target.constructor.prototype) {\n\t        Object.defineProperty(target.constructor.prototype, key, {\n\t            configurable: true, enumerable: false, writable: false,\n\t            value: wrappedAction\n\t        });\n\t    }\n\t    else {\n\t        Object.defineProperty(target, key, {\n\t            configurable: true, enumerable: false, writable: false,\n\t            value: wrappedAction\n\t        });\n\t    }\n\t}, function (key) {\n\t    return this[key];\n\t}, function () {\n\t    invariant(false, \"It is not allowed to assign new values to @action fields\");\n\t}, false, true);\n\tfunction action(arg1, arg2, arg3, arg4) {\n\t    if (arguments.length === 1 && typeof arg1 === \"function\")\n\t        return actionImplementation(arg1.name || \"<unnamed action>\", arg1);\n\t    if (arguments.length === 2 && typeof arg2 === \"function\")\n\t        return actionImplementation(arg1, arg2);\n\t    return actionDecorator.apply(null, arguments);\n\t}\n\texports.action = action;\n\tfunction isAction(thing) {\n\t    return typeof thing === \"function\" && thing.isMobxAction === true;\n\t}\n\texports.isAction = isAction;\n\tfunction runInAction(arg1, arg2, arg3) {\n\t    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n\t    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n\t    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n\t    invariant(typeof fn === \"function\", \"`runInAction` expects a function\");\n\t    invariant(fn.length === 0, \"`runInAction` expects a function without arguments\");\n\t    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n\t    return executeWrapped(actionName, fn, scope, undefined);\n\t}\n\texports.runInAction = runInAction;\n\tfunction actionImplementation(actionName, fn) {\n\t    invariant(typeof fn === \"function\", \"`action` can only be invoked on functions\");\n\t    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n\t    var res = function () {\n\t        return executeWrapped(actionName, fn, this, arguments);\n\t    };\n\t    res.isMobxAction = true;\n\t    return res;\n\t}\n\tfunction executeWrapped(actionName, fn, scope, args) {\n\t    var ds = globalState.derivationStack;\n\t    invariant(!(ds[ds.length - 1] instanceof ComputedValue), \"Computed values or transformers should not invoke actions or trigger other side effects\");\n\t    var notifySpy = isSpyEnabled();\n\t    var startTime;\n\t    if (notifySpy) {\n\t        startTime = Date.now();\n\t        var flattendArgs = [];\n\t        for (var i = 0, l = args.length; i < l; i++)\n\t            flattendArgs.push(args[i]);\n\t        spyReportStart({\n\t            type: \"action\",\n\t            name: actionName,\n\t            fn: fn,\n\t            target: scope,\n\t            arguments: flattendArgs\n\t        });\n\t    }\n\t    var prevUntracked = untrackedStart();\n\t    transactionStart(actionName, scope, false);\n\t    var prevAllowStateChanges = allowStateChangesStart(true);\n\t    try {\n\t        return fn.apply(scope, args);\n\t    }\n\t    finally {\n\t        allowStateChangesEnd(prevAllowStateChanges);\n\t        transactionEnd(false);\n\t        untrackedEnd(prevUntracked);\n\t        if (notifySpy)\n\t            spyReportEnd({ time: Date.now() - startTime });\n\t    }\n\t}\n\tfunction useStrict(strict) {\n\t    invariant(globalState.derivationStack.length === 0, \"It is not allowed to set `useStrict` when a derivation is running\");\n\t    globalState.strictMode = strict;\n\t    globalState.allowStateChanges = !strict;\n\t}\n\texports.useStrict = useStrict;\n\tfunction allowStateChanges(allowStateChanges, func) {\n\t    var prev = allowStateChangesStart(allowStateChanges);\n\t    var res = func();\n\t    allowStateChangesEnd(prev);\n\t    return res;\n\t}\n\tfunction allowStateChangesStart(allowStateChanges) {\n\t    var prev = globalState.allowStateChanges;\n\t    globalState.allowStateChanges = allowStateChanges;\n\t    return prev;\n\t}\n\tfunction allowStateChangesEnd(prev) {\n\t    globalState.allowStateChanges = prev;\n\t}\n\tfunction propagateAtomReady(atom) {\n\t    invariant(atom.isDirty, \"atom not dirty\");\n\t    atom.isDirty = false;\n\t    propagateReadiness(atom, true);\n\t}\n\tvar Atom = (function () {\n\t    function Atom(name, onBecomeObserved, onBecomeUnobserved) {\n\t        if (name === void 0) { name = \"Atom@\" + getNextId(); }\n\t        if (onBecomeObserved === void 0) { onBecomeObserved = noop; }\n\t        if (onBecomeUnobserved === void 0) { onBecomeUnobserved = noop; }\n\t        this.name = name;\n\t        this.onBecomeObserved = onBecomeObserved;\n\t        this.onBecomeUnobserved = onBecomeUnobserved;\n\t        this.isDirty = false;\n\t        this.staleObservers = [];\n\t        this.observers = [];\n\t    }\n\t    Atom.prototype.reportObserved = function () {\n\t        reportObserved(this);\n\t    };\n\t    Atom.prototype.reportChanged = function () {\n\t        if (!this.isDirty) {\n\t            this.reportStale();\n\t            this.reportReady();\n\t        }\n\t    };\n\t    Atom.prototype.reportStale = function () {\n\t        if (!this.isDirty) {\n\t            this.isDirty = true;\n\t            propagateStaleness(this);\n\t        }\n\t    };\n\t    Atom.prototype.reportReady = function () {\n\t        invariant(this.isDirty, \"atom not dirty\");\n\t        if (globalState.inTransaction > 0)\n\t            globalState.changedAtoms.push(this);\n\t        else {\n\t            propagateAtomReady(this);\n\t            runReactions();\n\t        }\n\t    };\n\t    Atom.prototype.toString = function () {\n\t        return this.name;\n\t    };\n\t    return Atom;\n\t}());\n\texports.Atom = Atom;\n\tvar ComputedValue = (function () {\n\t    function ComputedValue(derivation, scope, compareStructural, name) {\n\t        this.derivation = derivation;\n\t        this.scope = scope;\n\t        this.compareStructural = compareStructural;\n\t        this.isLazy = true;\n\t        this.isComputing = false;\n\t        this.staleObservers = [];\n\t        this.observers = [];\n\t        this.observing = [];\n\t        this.dependencyChangeCount = 0;\n\t        this.dependencyStaleCount = 0;\n\t        this.value = undefined;\n\t        this.name = name || \"ComputedValue@\" + getNextId();\n\t    }\n\t    ComputedValue.prototype.peek = function () {\n\t        this.isComputing = true;\n\t        var prevAllowStateChanges = allowStateChangesStart(false);\n\t        var res = this.derivation.call(this.scope);\n\t        allowStateChangesEnd(prevAllowStateChanges);\n\t        this.isComputing = false;\n\t        return res;\n\t    };\n\t    ;\n\t    ComputedValue.prototype.onBecomeObserved = function () {\n\t    };\n\t    ComputedValue.prototype.onBecomeUnobserved = function () {\n\t        for (var i = 0, l = this.observing.length; i < l; i++)\n\t            removeObserver(this.observing[i], this);\n\t        this.observing = [];\n\t        this.isLazy = true;\n\t        this.value = undefined;\n\t    };\n\t    ComputedValue.prototype.onDependenciesReady = function () {\n\t        var changed = this.trackAndCompute();\n\t        return changed;\n\t    };\n\t    ComputedValue.prototype.get = function () {\n\t        invariant(!this.isComputing, \"Cycle detected\", this.derivation);\n\t        reportObserved(this);\n\t        if (this.dependencyStaleCount > 0) {\n\t            return this.peek();\n\t        }\n\t        if (this.isLazy) {\n\t            if (isComputingDerivation()) {\n\t                this.isLazy = false;\n\t                this.trackAndCompute();\n\t            }\n\t            else {\n\t                return this.peek();\n\t            }\n\t        }\n\t        return this.value;\n\t    };\n\t    ComputedValue.prototype.set = function (_) {\n\t        throw new Error(\"[ComputedValue '\" + name + \"'] It is not possible to assign a new value to a computed value.\");\n\t    };\n\t    ComputedValue.prototype.trackAndCompute = function () {\n\t        if (isSpyEnabled()) {\n\t            spyReport({\n\t                object: this,\n\t                type: \"compute\",\n\t                fn: this.derivation,\n\t                target: this.scope\n\t            });\n\t        }\n\t        var oldValue = this.value;\n\t        var newValue = this.value = trackDerivedFunction(this, this.peek);\n\t        return valueDidChange(this.compareStructural, newValue, oldValue);\n\t    };\n\t    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n\t        var _this = this;\n\t        var firstTime = true;\n\t        var prevValue = undefined;\n\t        return autorun(function () {\n\t            var newValue = _this.get();\n\t            if (!firstTime || fireImmediately) {\n\t                var prevU = untrackedStart();\n\t                listener(newValue, prevValue);\n\t                untrackedEnd(prevU);\n\t            }\n\t            firstTime = false;\n\t            prevValue = newValue;\n\t        });\n\t    };\n\t    ComputedValue.prototype.toJSON = function () {\n\t        return this.get();\n\t    };\n\t    ComputedValue.prototype.toString = function () {\n\t        return this.name + \"[\" + this.derivation.toString() + \"]\";\n\t    };\n\t    ComputedValue.prototype.whyRun = function () {\n\t        var isTracking = globalState.derivationStack.length > 0;\n\t        var observing = unique(this.observing).map(function (dep) { return dep.name; });\n\t        var observers = unique(this.observers).map(function (dep) { return dep.name; });\n\t        var runReason = (this.isComputing\n\t            ? isTracking\n\t                ? this.observers.length > 0\n\t                    ? RunReason.INVALIDATED\n\t                    : RunReason.REQUIRED\n\t                : RunReason.PEEK\n\t            : RunReason.NOT_RUNNING);\n\t        if (runReason === RunReason.REQUIRED) {\n\t            var requiredBy = globalState.derivationStack[globalState.derivationStack.length - 2];\n\t            if (requiredBy)\n\t                observers.push(requiredBy.name);\n\t        }\n\t        return ((\"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + runReasonTexts[runReason] + \" \" + ((runReason === RunReason.NOT_RUNNING) && this.dependencyStaleCount > 0 ? \"(a next run is scheduled)\" : \"\") + \"\\n\") +\n\t            (this.isLazy\n\t                ?\n\t                    \" * This computation is suspended (not in use by any reaction) and won't run automatically.\\n\\tDidn't expect this computation to be suspended at this point?\\n\\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\\n\"\n\t                :\n\t                    \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + ((this.isComputing && isTracking) ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\tMissing items in this list?\\n\\t  1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n\\t  2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\"));\n\t    };\n\t    return ComputedValue;\n\t}());\n\tvar RunReason;\n\t(function (RunReason) {\n\t    RunReason[RunReason[\"PEEK\"] = 0] = \"PEEK\";\n\t    RunReason[RunReason[\"INVALIDATED\"] = 1] = \"INVALIDATED\";\n\t    RunReason[RunReason[\"REQUIRED\"] = 2] = \"REQUIRED\";\n\t    RunReason[RunReason[\"NOT_RUNNING\"] = 3] = \"NOT_RUNNING\";\n\t})(RunReason || (RunReason = {}));\n\tvar runReasonTexts = (_a = {},\n\t    _a[RunReason.PEEK] = \"[peek] The value of this computed value was requested outside an reaction\",\n\t    _a[RunReason.INVALIDATED] = \"[invalidated] Some observables used by this computation did change\",\n\t    _a[RunReason.REQUIRED] = \"[started] This computation is required by another computed value / reaction\",\n\t    _a[RunReason.NOT_RUNNING] = \"[idle] This compution is currently not running\",\n\t    _a\n\t);\n\tfunction isComputingDerivation() {\n\t    return globalState.derivationStack.length > 0;\n\t}\n\tfunction checkIfStateModificationsAreAllowed() {\n\t    if (!globalState.allowStateChanges) {\n\t        invariant(false, globalState.strictMode\n\t            ? \"It is not allowed to create or change state outside an `action` when MobX is in strict mode. Wrap the current method in `action` if this state change is intended\"\n\t            : \"It is not allowed to change the state when a computed value or transformer is being evaluated. Use 'autorun' to create reactive functions with side-effects.\");\n\t    }\n\t}\n\tfunction notifyDependencyStale(derivation) {\n\t    if (++derivation.dependencyStaleCount === 1) {\n\t        propagateStaleness(derivation);\n\t    }\n\t}\n\tfunction notifyDependencyReady(derivation, dependencyDidChange) {\n\t    invariant(derivation.dependencyStaleCount > 0, \"unexpected ready notification\");\n\t    if (dependencyDidChange)\n\t        derivation.dependencyChangeCount += 1;\n\t    if (--derivation.dependencyStaleCount === 0) {\n\t        if (derivation.dependencyChangeCount > 0) {\n\t            derivation.dependencyChangeCount = 0;\n\t            var changed = derivation.onDependenciesReady();\n\t            propagateReadiness(derivation, changed);\n\t        }\n\t        else {\n\t            propagateReadiness(derivation, false);\n\t        }\n\t    }\n\t}\n\tfunction trackDerivedFunction(derivation, f) {\n\t    var hasException = true;\n\t    var prevObserving = derivation.observing;\n\t    derivation.observing = [];\n\t    globalState.derivationStack.push(derivation);\n\t    var prevTracking = globalState.isTracking;\n\t    globalState.isTracking = true;\n\t    try {\n\t        var result = f.call(derivation);\n\t        hasException = false;\n\t        bindDependencies(derivation, prevObserving);\n\t        globalState.isTracking = prevTracking;\n\t        return result;\n\t    }\n\t    finally {\n\t        if (hasException) {\n\t            var message = (\"[mobx] An uncaught exception occurred while calculating your computed value, autorun or transformer. Or inside the render() method of an observer based React component. \" +\n\t                \"These methods should never throw exceptions as MobX will usually not be able to recover from them. \" +\n\t                (\"Please enable 'Pause on (caught) exceptions' in your debugger to find the root cause. In: '\" + derivation.name + \"'\"));\n\t            if (isSpyEnabled()) {\n\t                spyReport({\n\t                    type: \"error\",\n\t                    object: this,\n\t                    message: message\n\t                });\n\t            }\n\t            console.error(message);\n\t            resetGlobalState();\n\t        }\n\t    }\n\t}\n\tfunction bindDependencies(derivation, prevObserving) {\n\t    globalState.derivationStack.length -= 1;\n\t    var _a = quickDiff(derivation.observing, prevObserving), added = _a[0], removed = _a[1];\n\t    for (var i = 0, l = added.length; i < l; i++) {\n\t        var dependency = added[i];\n\t        invariant(!findCycle(derivation, dependency), \"Cycle detected\", derivation);\n\t        addObserver(added[i], derivation);\n\t    }\n\t    for (var i = 0, l = removed.length; i < l; i++)\n\t        removeObserver(removed[i], derivation);\n\t}\n\tfunction findCycle(needle, node) {\n\t    if (needle === node)\n\t        return true;\n\t    var obs = node.observing;\n\t    if (obs === undefined)\n\t        return false;\n\t    for (var l = obs.length, i = 0; i < l; i++)\n\t        if (findCycle(needle, obs[i]))\n\t            return true;\n\t    return false;\n\t}\n\tfunction untracked(action) {\n\t    var prev = untrackedStart();\n\t    var res = action();\n\t    untrackedEnd(prev);\n\t    return res;\n\t}\n\texports.untracked = untracked;\n\tfunction untrackedStart() {\n\t    var prev = globalState.isTracking;\n\t    globalState.isTracking = false;\n\t    return prev;\n\t}\n\tfunction untrackedEnd(prev) {\n\t    globalState.isTracking = prev;\n\t}\n\tvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\"];\n\tvar MobXGlobals = (function () {\n\t    function MobXGlobals() {\n\t        this.version = 2;\n\t        this.derivationStack = [];\n\t        this.mobxGuid = 0;\n\t        this.inTransaction = 0;\n\t        this.isTracking = false;\n\t        this.isRunningReactions = false;\n\t        this.changedAtoms = [];\n\t        this.pendingReactions = [];\n\t        this.allowStateChanges = true;\n\t        this.strictMode = false;\n\t        this.resetId = 0;\n\t        this.spyListeners = [];\n\t    }\n\t    return MobXGlobals;\n\t}());\n\tvar globalState = (function () {\n\t    var res = new MobXGlobals();\n\t    if (global.__mobservableTrackingStack || global.__mobservableViewStack)\n\t        throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n\t    if (global.__mobxGlobal && global.__mobxGlobal.version !== res.version)\n\t        throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n\t    if (global.__mobxGlobal)\n\t        return global.__mobxGlobal;\n\t    return global.__mobxGlobal = res;\n\t})();\n\tfunction registerGlobals() {\n\t}\n\tfunction resetGlobalState() {\n\t    globalState.resetId++;\n\t    var defaultGlobals = new MobXGlobals();\n\t    for (var key in defaultGlobals)\n\t        if (persistentKeys.indexOf(key) === -1)\n\t            globalState[key] = defaultGlobals[key];\n\t    globalState.allowStateChanges = !globalState.strictMode;\n\t}\n\tfunction addObserver(observable, node) {\n\t    var obs = observable.observers, l = obs.length;\n\t    obs[l] = node;\n\t    if (l === 0)\n\t        observable.onBecomeObserved();\n\t}\n\tfunction removeObserver(observable, node) {\n\t    var obs = observable.observers, idx = obs.indexOf(node);\n\t    if (idx !== -1)\n\t        obs.splice(idx, 1);\n\t    if (obs.length === 0)\n\t        observable.onBecomeUnobserved();\n\t}\n\tfunction reportObserved(observable) {\n\t    if (globalState.isTracking === false)\n\t        return;\n\t    var derivationStack = globalState.derivationStack;\n\t    var deps = derivationStack[derivationStack.length - 1].observing;\n\t    var depslength = deps.length;\n\t    if (deps[depslength - 1] !== observable && deps[depslength - 2] !== observable)\n\t        deps[depslength] = observable;\n\t}\n\tfunction propagateStaleness(observable) {\n\t    var os = observable.observers.slice();\n\t    os.forEach(notifyDependencyStale);\n\t    observable.staleObservers = observable.staleObservers.concat(os);\n\t}\n\tfunction propagateReadiness(observable, valueDidActuallyChange) {\n\t    observable.staleObservers.splice(0).forEach(function (o) { return notifyDependencyReady(o, valueDidActuallyChange); });\n\t}\n\tvar Reaction = (function () {\n\t    function Reaction(name, onInvalidate) {\n\t        if (name === void 0) { name = \"Reaction@\" + getNextId(); }\n\t        this.name = name;\n\t        this.onInvalidate = onInvalidate;\n\t        this.staleObservers = EMPTY_ARRAY;\n\t        this.observers = EMPTY_ARRAY;\n\t        this.observing = [];\n\t        this.dependencyChangeCount = 0;\n\t        this.dependencyStaleCount = 0;\n\t        this.isDisposed = false;\n\t        this._isScheduled = false;\n\t        this._isTrackPending = false;\n\t        this._isRunning = false;\n\t    }\n\t    Reaction.prototype.onBecomeObserved = function () {\n\t    };\n\t    Reaction.prototype.onBecomeUnobserved = function () {\n\t    };\n\t    Reaction.prototype.onDependenciesReady = function () {\n\t        this.schedule();\n\t        return false;\n\t    };\n\t    Reaction.prototype.schedule = function () {\n\t        if (!this._isScheduled) {\n\t            this._isScheduled = true;\n\t            globalState.pendingReactions.push(this);\n\t            runReactions();\n\t        }\n\t    };\n\t    Reaction.prototype.isScheduled = function () {\n\t        return this.dependencyStaleCount > 0 || this._isScheduled;\n\t    };\n\t    Reaction.prototype.runReaction = function () {\n\t        if (!this.isDisposed) {\n\t            this._isScheduled = false;\n\t            this._isTrackPending = true;\n\t            this.onInvalidate();\n\t            if (this._isTrackPending && isSpyEnabled()) {\n\t                spyReport({\n\t                    object: this,\n\t                    type: \"scheduled-reaction\"\n\t                });\n\t            }\n\t        }\n\t    };\n\t    Reaction.prototype.track = function (fn) {\n\t        var notify = isSpyEnabled();\n\t        var startTime;\n\t        if (notify) {\n\t            startTime = Date.now();\n\t            spyReportStart({\n\t                object: this,\n\t                type: \"reaction\",\n\t                fn: fn\n\t            });\n\t        }\n\t        this._isRunning = true;\n\t        trackDerivedFunction(this, fn);\n\t        this._isRunning = false;\n\t        this._isTrackPending = false;\n\t        if (notify) {\n\t            spyReportEnd({\n\t                time: Date.now() - startTime\n\t            });\n\t        }\n\t    };\n\t    Reaction.prototype.dispose = function () {\n\t        if (!this.isDisposed) {\n\t            this.isDisposed = true;\n\t            var deps = this.observing.splice(0);\n\t            for (var i = 0, l = deps.length; i < l; i++)\n\t                removeObserver(deps[i], this);\n\t        }\n\t    };\n\t    Reaction.prototype.getDisposer = function () {\n\t        var r = this.dispose.bind(this);\n\t        r.$mobx = this;\n\t        return r;\n\t    };\n\t    Reaction.prototype.toString = function () {\n\t        return \"Reaction[\" + this.name + \"]\";\n\t    };\n\t    Reaction.prototype.whyRun = function () {\n\t        var observing = unique(this.observing).map(function (dep) { return dep.name; });\n\t        return (\"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + ((this._isRunning) ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\tMissing items in this list?\\n\\t  1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n\\t  2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\");\n\t    };\n\t    return Reaction;\n\t}());\n\texports.Reaction = Reaction;\n\tvar MAX_REACTION_ITERATIONS = 100;\n\tfunction runReactions() {\n\t    if (globalState.isRunningReactions === true || globalState.inTransaction > 0)\n\t        return;\n\t    globalState.isRunningReactions = true;\n\t    var allReactions = globalState.pendingReactions;\n\t    var iterations = 0;\n\t    while (allReactions.length > 0) {\n\t        if (++iterations === MAX_REACTION_ITERATIONS)\n\t            throw new Error(\"Reaction doesn't converge to a stable state. Probably there is a cycle in the reactive function: \" + allReactions[0].toString());\n\t        var remainingReactions = allReactions.splice(0);\n\t        for (var i = 0, l = remainingReactions.length; i < l; i++)\n\t            remainingReactions[i].runReaction();\n\t    }\n\t    globalState.isRunningReactions = false;\n\t}\n\tvar spyEnabled = false;\n\tfunction isSpyEnabled() {\n\t    return spyEnabled;\n\t}\n\tfunction spyReport(event) {\n\t    if (!spyEnabled)\n\t        return false;\n\t    var listeners = globalState.spyListeners;\n\t    for (var i = 0, l = listeners.length; i < l; i++)\n\t        listeners[i](event);\n\t}\n\tfunction spyReportStart(event) {\n\t    var change = objectAssign({}, event, { spyReportStart: true });\n\t    spyReport(change);\n\t}\n\tvar END_EVENT = { spyReportEnd: true };\n\tfunction spyReportEnd(change) {\n\t    if (change)\n\t        spyReport(objectAssign({}, change, END_EVENT));\n\t    else\n\t        spyReport(END_EVENT);\n\t}\n\tfunction spy(listener) {\n\t    globalState.spyListeners.push(listener);\n\t    spyEnabled = globalState.spyListeners.length > 0;\n\t    return once(function () {\n\t        var idx = globalState.spyListeners.indexOf(listener);\n\t        if (idx !== -1)\n\t            globalState.spyListeners.splice(idx, 1);\n\t        spyEnabled = globalState.spyListeners.length > 0;\n\t    });\n\t}\n\texports.spy = spy;\n\tfunction trackTransitions(onReport) {\n\t    deprecated(\"trackTransitions is deprecated. Use mobx.spy instead\");\n\t    if (typeof onReport === \"boolean\") {\n\t        deprecated(\"trackTransitions only takes a single callback function. If you are using the mobx-react-devtools, please update them first\");\n\t        onReport = arguments[1];\n\t    }\n\t    if (!onReport) {\n\t        deprecated(\"trackTransitions without callback has been deprecated and is a no-op now. If you are using the mobx-react-devtools, please update them first\");\n\t        return function () { };\n\t    }\n\t    return spy(onReport);\n\t}\n\tfunction transaction(action, thisArg, report) {\n\t    if (thisArg === void 0) { thisArg = undefined; }\n\t    if (report === void 0) { report = true; }\n\t    transactionStart((action.name) || \"anonymous transaction\", thisArg, report);\n\t    var res = action.call(thisArg);\n\t    transactionEnd(report);\n\t    return res;\n\t}\n\texports.transaction = transaction;\n\tfunction transactionStart(name, thisArg, report) {\n\t    if (thisArg === void 0) { thisArg = undefined; }\n\t    if (report === void 0) { report = true; }\n\t    globalState.inTransaction += 1;\n\t    if (report && isSpyEnabled()) {\n\t        spyReportStart({\n\t            type: \"transaction\",\n\t            target: thisArg,\n\t            name: name\n\t        });\n\t    }\n\t}\n\tfunction transactionEnd(report) {\n\t    if (report === void 0) { report = true; }\n\t    if (--globalState.inTransaction === 0) {\n\t        var values = globalState.changedAtoms.splice(0);\n\t        for (var i = 0, l = values.length; i < l; i++)\n\t            propagateAtomReady(values[i]);\n\t        runReactions();\n\t    }\n\t    if (report && isSpyEnabled())\n\t        spyReportEnd();\n\t}\n\tfunction hasInterceptors(interceptable) {\n\t    return (interceptable.interceptors && interceptable.interceptors.length > 0);\n\t}\n\tfunction registerInterceptor(interceptable, handler) {\n\t    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n\t    interceptors.push(handler);\n\t    return once(function () {\n\t        var idx = interceptors.indexOf(handler);\n\t        if (idx !== -1)\n\t            interceptors.splice(idx, 1);\n\t    });\n\t}\n\tfunction interceptChange(interceptable, change) {\n\t    var prevU = untrackedStart();\n\t    var interceptors = interceptable.interceptors;\n\t    for (var i = 0, l = interceptors.length; i < l; i++) {\n\t        change = interceptors[i](change);\n\t        invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n\t        if (!change)\n\t            return null;\n\t    }\n\t    untrackedEnd(prevU);\n\t    return change;\n\t}\n\tfunction hasListeners(listenable) {\n\t    return listenable.changeListeners && listenable.changeListeners.length > 0;\n\t}\n\tfunction registerListener(listenable, handler) {\n\t    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n\t    listeners.push(handler);\n\t    return once(function () {\n\t        var idx = listeners.indexOf(handler);\n\t        if (idx !== -1)\n\t            listeners.splice(idx, 1);\n\t    });\n\t}\n\tfunction notifyListeners(listenable, change) {\n\t    var prevU = untrackedStart();\n\t    var listeners = listenable.changeListeners;\n\t    if (!listeners)\n\t        return;\n\t    listeners = listeners.slice();\n\t    if (Array.isArray(change)) {\n\t        for (var i = 0, l = listeners.length; i < l; i++)\n\t            listeners[i].apply(null, change);\n\t    }\n\t    else {\n\t        for (var i = 0, l = listeners.length; i < l; i++)\n\t            listeners[i](change);\n\t    }\n\t    untrackedEnd(prevU);\n\t}\n\tvar ValueMode;\n\t(function (ValueMode) {\n\t    ValueMode[ValueMode[\"Recursive\"] = 0] = \"Recursive\";\n\t    ValueMode[ValueMode[\"Reference\"] = 1] = \"Reference\";\n\t    ValueMode[ValueMode[\"Structure\"] = 2] = \"Structure\";\n\t    ValueMode[ValueMode[\"Flat\"] = 3] = \"Flat\";\n\t})(ValueMode || (ValueMode = {}));\n\tfunction asReference(value) {\n\t    return new AsReference(value);\n\t}\n\texports.asReference = asReference;\n\tfunction asStructure(value) {\n\t    return new AsStructure(value);\n\t}\n\texports.asStructure = asStructure;\n\tfunction asFlat(value) {\n\t    return new AsFlat(value);\n\t}\n\texports.asFlat = asFlat;\n\tvar AsReference = (function () {\n\t    function AsReference(value) {\n\t        this.value = value;\n\t        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n\t    }\n\t    return AsReference;\n\t}());\n\tvar AsStructure = (function () {\n\t    function AsStructure(value) {\n\t        this.value = value;\n\t        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n\t    }\n\t    return AsStructure;\n\t}());\n\tvar AsFlat = (function () {\n\t    function AsFlat(value) {\n\t        this.value = value;\n\t        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n\t    }\n\t    return AsFlat;\n\t}());\n\tfunction asMap(data, modifierFunc) {\n\t    return map(data, modifierFunc);\n\t}\n\texports.asMap = asMap;\n\tfunction getValueModeFromValue(value, defaultMode) {\n\t    if (value instanceof AsReference)\n\t        return [ValueMode.Reference, value.value];\n\t    if (value instanceof AsStructure)\n\t        return [ValueMode.Structure, value.value];\n\t    if (value instanceof AsFlat)\n\t        return [ValueMode.Flat, value.value];\n\t    return [defaultMode, value];\n\t}\n\tfunction getValueModeFromModifierFunc(func) {\n\t    if (func === asReference)\n\t        return ValueMode.Reference;\n\t    else if (func === asStructure)\n\t        return ValueMode.Structure;\n\t    else if (func === asFlat)\n\t        return ValueMode.Flat;\n\t    invariant(func === undefined, \"Cannot determine value mode from function. Please pass in one of these: mobx.asReference, mobx.asStructure or mobx.asFlat, got: \" + func);\n\t    return ValueMode.Recursive;\n\t}\n\tfunction makeChildObservable(value, parentMode, name) {\n\t    var childMode;\n\t    if (isObservable(value))\n\t        return value;\n\t    switch (parentMode) {\n\t        case ValueMode.Reference:\n\t            return value;\n\t        case ValueMode.Flat:\n\t            assertUnwrapped(value, \"Items inside 'asFlat' cannot have modifiers\");\n\t            childMode = ValueMode.Reference;\n\t            break;\n\t        case ValueMode.Structure:\n\t            assertUnwrapped(value, \"Items inside 'asStructure' cannot have modifiers\");\n\t            childMode = ValueMode.Structure;\n\t            break;\n\t        case ValueMode.Recursive:\n\t            _a = getValueModeFromValue(value, ValueMode.Recursive), childMode = _a[0], value = _a[1];\n\t            break;\n\t        default:\n\t            invariant(false, \"Illegal State\");\n\t    }\n\t    if (Array.isArray(value))\n\t        return createObservableArray(value, childMode, name);\n\t    if (isPlainObject(value) && Object.isExtensible(value))\n\t        return extendObservableHelper(value, value, childMode, name);\n\t    return value;\n\t    var _a;\n\t}\n\tfunction assertUnwrapped(value, message) {\n\t    if (value instanceof AsReference || value instanceof AsStructure || value instanceof AsFlat)\n\t        throw new Error(\"[mobx] asStructure / asReference / asFlat cannot be used here. \" + message);\n\t}\n\tvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\n\tvar StubArray = (function () {\n\t    function StubArray() {\n\t    }\n\t    return StubArray;\n\t}());\n\tStubArray.prototype = [];\n\tvar ObservableArrayAdministration = (function () {\n\t    function ObservableArrayAdministration(name, mode, array, owned) {\n\t        this.mode = mode;\n\t        this.array = array;\n\t        this.owned = owned;\n\t        this.lastKnownLength = 0;\n\t        this.interceptors = null;\n\t        this.changeListeners = null;\n\t        this.atom = new Atom(name || (\"ObservableArray@\" + getNextId()));\n\t    }\n\t    ObservableArrayAdministration.prototype.makeReactiveArrayItem = function (value) {\n\t        assertUnwrapped(value, \"Array values cannot have modifiers\");\n\t        if (this.mode === ValueMode.Flat || this.mode === ValueMode.Reference)\n\t            return value;\n\t        return makeChildObservable(value, this.mode, this.atom.name + \"[..]\");\n\t    };\n\t    ObservableArrayAdministration.prototype.intercept = function (handler) {\n\t        return registerInterceptor(this, handler);\n\t    };\n\t    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n\t        if (fireImmediately === void 0) { fireImmediately = false; }\n\t        if (fireImmediately) {\n\t            listener({\n\t                object: this.array,\n\t                type: \"splice\",\n\t                index: 0,\n\t                added: this.values.slice(),\n\t                addedCount: this.values.length,\n\t                removed: [],\n\t                removedCount: 0\n\t            });\n\t        }\n\t        return registerListener(this, listener);\n\t    };\n\t    ObservableArrayAdministration.prototype.getArrayLength = function () {\n\t        this.atom.reportObserved();\n\t        return this.values.length;\n\t    };\n\t    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n\t        if (typeof newLength !== \"number\" || newLength < 0)\n\t            throw new Error(\"[mobx.array] Out of range: \" + newLength);\n\t        var currentLength = this.values.length;\n\t        if (newLength === currentLength)\n\t            return;\n\t        else if (newLength > currentLength)\n\t            this.spliceWithArray(currentLength, 0, new Array(newLength - currentLength));\n\t        else\n\t            this.spliceWithArray(newLength, currentLength - newLength);\n\t    };\n\t    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n\t        if (oldLength !== this.lastKnownLength)\n\t            throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n\t        this.lastKnownLength += delta;\n\t        if (delta > 0 && oldLength + delta > OBSERVABLE_ARRAY_BUFFER_SIZE)\n\t            reserveArrayBuffer(oldLength + delta);\n\t    };\n\t    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n\t        checkIfStateModificationsAreAllowed();\n\t        var length = this.values.length;\n\t        if (index === undefined)\n\t            index = 0;\n\t        else if (index > length)\n\t            index = length;\n\t        else if (index < 0)\n\t            index = Math.max(0, length + index);\n\t        if (arguments.length === 1)\n\t            deleteCount = length - index;\n\t        else if (deleteCount === undefined || deleteCount === null)\n\t            deleteCount = 0;\n\t        else\n\t            deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n\t        if (newItems === undefined)\n\t            newItems = [];\n\t        if (hasInterceptors(this)) {\n\t            var change = interceptChange(this, {\n\t                object: this.array,\n\t                type: \"splice\",\n\t                index: index,\n\t                removedCount: deleteCount,\n\t                added: newItems\n\t            });\n\t            if (!change)\n\t                return EMPTY_ARRAY;\n\t            deleteCount = change.removedCount;\n\t            newItems = change.added;\n\t        }\n\t        newItems = newItems.map(this.makeReactiveArrayItem, this);\n\t        var lengthDelta = newItems.length - deleteCount;\n\t        this.updateArrayLength(length, lengthDelta);\n\t        var res = (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n\t        if (deleteCount !== 0 || newItems.length !== 0)\n\t            this.notifyArraySplice(index, newItems, res);\n\t        return res;\n\t        var _a;\n\t    };\n\t    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n\t        var notifySpy = !this.owned && isSpyEnabled();\n\t        var notify = hasListeners(this);\n\t        var change = notify || notifySpy ? {\n\t            object: this.array,\n\t            type: \"update\",\n\t            index: index, newValue: newValue, oldValue: oldValue\n\t        } : null;\n\t        if (notifySpy)\n\t            spyReportStart(change);\n\t        this.atom.reportChanged();\n\t        if (notify)\n\t            notifyListeners(this, change);\n\t        if (notifySpy)\n\t            spyReportEnd();\n\t    };\n\t    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n\t        var notifySpy = !this.owned && isSpyEnabled();\n\t        var notify = hasListeners(this);\n\t        var change = notify || notifySpy ? {\n\t            object: this.array,\n\t            type: \"splice\",\n\t            index: index, removed: removed, added: added,\n\t            removedCount: removed.length,\n\t            addedCount: added.length\n\t        } : null;\n\t        if (notifySpy)\n\t            spyReportStart(change);\n\t        this.atom.reportChanged();\n\t        if (notify)\n\t            notifyListeners(this, change);\n\t        if (notifySpy)\n\t            spyReportEnd();\n\t    };\n\t    return ObservableArrayAdministration;\n\t}());\n\tvar ObservableArray = (function (_super) {\n\t    __extends(ObservableArray, _super);\n\t    function ObservableArray(initialValues, mode, name, owned) {\n\t        if (owned === void 0) { owned = false; }\n\t        _super.call(this);\n\t        var adm = new ObservableArrayAdministration(name, mode, this, owned);\n\t        Object.defineProperty(this, \"$mobx\", {\n\t            enumerable: false,\n\t            configurable: false,\n\t            writable: false,\n\t            value: adm\n\t        });\n\t        if (initialValues && initialValues.length) {\n\t            adm.updateArrayLength(0, initialValues.length);\n\t            adm.values = initialValues.map(adm.makeReactiveArrayItem, adm);\n\t            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n\t        }\n\t        else {\n\t            adm.values = [];\n\t        }\n\t    }\n\t    ObservableArray.prototype.intercept = function (handler) {\n\t        return this.$mobx.intercept(handler);\n\t    };\n\t    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n\t        if (fireImmediately === void 0) { fireImmediately = false; }\n\t        return this.$mobx.observe(listener, fireImmediately);\n\t    };\n\t    ObservableArray.prototype.clear = function () {\n\t        return this.splice(0);\n\t    };\n\t    ObservableArray.prototype.replace = function (newItems) {\n\t        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n\t    };\n\t    ObservableArray.prototype.toJS = function () {\n\t        return this.slice();\n\t    };\n\t    ObservableArray.prototype.toJSON = function () {\n\t        return this.toJS();\n\t    };\n\t    ObservableArray.prototype.peek = function () {\n\t        return this.$mobx.values;\n\t    };\n\t    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n\t        if (fromIndex === void 0) { fromIndex = 0; }\n\t        this.$mobx.atom.reportObserved();\n\t        var items = this.$mobx.values, l = items.length;\n\t        for (var i = fromIndex; i < l; i++)\n\t            if (predicate.call(thisArg, items[i], i, this))\n\t                return items[i];\n\t        return null;\n\t    };\n\t    ObservableArray.prototype.splice = function (index, deleteCount) {\n\t        var newItems = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            newItems[_i - 2] = arguments[_i];\n\t        }\n\t        switch (arguments.length) {\n\t            case 0:\n\t                return [];\n\t            case 1:\n\t                return this.$mobx.spliceWithArray(index);\n\t            case 2:\n\t                return this.$mobx.spliceWithArray(index, deleteCount);\n\t        }\n\t        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n\t    };\n\t    ObservableArray.prototype.push = function () {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i - 0] = arguments[_i];\n\t        }\n\t        var adm = this.$mobx;\n\t        adm.spliceWithArray(adm.values.length, 0, items);\n\t        return adm.values.length;\n\t    };\n\t    ObservableArray.prototype.pop = function () {\n\t        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n\t    };\n\t    ObservableArray.prototype.shift = function () {\n\t        return this.splice(0, 1)[0];\n\t    };\n\t    ObservableArray.prototype.unshift = function () {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i - 0] = arguments[_i];\n\t        }\n\t        var adm = this.$mobx;\n\t        adm.spliceWithArray(0, 0, items);\n\t        return adm.values.length;\n\t    };\n\t    ObservableArray.prototype.reverse = function () {\n\t        this.$mobx.atom.reportObserved();\n\t        var clone = this.slice();\n\t        return clone.reverse.apply(clone, arguments);\n\t    };\n\t    ObservableArray.prototype.sort = function (compareFn) {\n\t        this.$mobx.atom.reportObserved();\n\t        var clone = this.slice();\n\t        return clone.sort.apply(clone, arguments);\n\t    };\n\t    ObservableArray.prototype.remove = function (value) {\n\t        var idx = this.$mobx.values.indexOf(value);\n\t        if (idx > -1) {\n\t            this.splice(idx, 1);\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    ObservableArray.prototype.toString = function () {\n\t        return \"[mobx.array] \" + Array.prototype.toString.apply(this.$mobx.values, arguments);\n\t    };\n\t    ObservableArray.prototype.toLocaleString = function () {\n\t        return \"[mobx.array] \" + Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n\t    };\n\t    return ObservableArray;\n\t}(StubArray));\n\tmakeNonEnumerable(ObservableArray.prototype, [\n\t    \"constructor\",\n\t    \"observe\",\n\t    \"clear\",\n\t    \"replace\",\n\t    \"toJSON\",\n\t    \"peek\",\n\t    \"find\",\n\t    \"splice\",\n\t    \"push\",\n\t    \"pop\",\n\t    \"shift\",\n\t    \"unshift\",\n\t    \"reverse\",\n\t    \"sort\",\n\t    \"remove\",\n\t    \"toString\",\n\t    \"toLocaleString\"\n\t]);\n\tObject.defineProperty(ObservableArray.prototype, \"length\", {\n\t    enumerable: false,\n\t    configurable: true,\n\t    get: function () {\n\t        return this.$mobx.getArrayLength();\n\t    },\n\t    set: function (newLength) {\n\t        this.$mobx.setArrayLength(newLength);\n\t    }\n\t});\n\t[\n\t    \"concat\",\n\t    \"every\",\n\t    \"filter\",\n\t    \"forEach\",\n\t    \"indexOf\",\n\t    \"join\",\n\t    \"lastIndexOf\",\n\t    \"map\",\n\t    \"reduce\",\n\t    \"reduceRight\",\n\t    \"slice\",\n\t    \"some\"\n\t].forEach(function (funcName) {\n\t    var baseFunc = Array.prototype[funcName];\n\t    Object.defineProperty(ObservableArray.prototype, funcName, {\n\t        configurable: false,\n\t        writable: true,\n\t        enumerable: false,\n\t        value: function () {\n\t            this.$mobx.atom.reportObserved();\n\t            return baseFunc.apply(this.$mobx.values, arguments);\n\t        }\n\t    });\n\t});\n\tfunction createArrayBufferItem(index) {\n\t    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n\t        enumerable: false,\n\t        configurable: false,\n\t        set: createArraySetter(index),\n\t        get: createArrayGetter(index)\n\t    });\n\t}\n\tfunction createArraySetter(index) {\n\t    return function (newValue) {\n\t        var adm = this.$mobx;\n\t        var values = adm.values;\n\t        assertUnwrapped(newValue, \"Modifiers cannot be used on array values. For non-reactive array values use makeReactive(asFlat(array)).\");\n\t        if (index < values.length) {\n\t            checkIfStateModificationsAreAllowed();\n\t            var oldValue = values[index];\n\t            if (hasInterceptors(adm)) {\n\t                var change = interceptChange(adm, {\n\t                    type: \"update\",\n\t                    object: adm.array,\n\t                    index: index, newValue: newValue\n\t                });\n\t                if (!change)\n\t                    return;\n\t                newValue = change.newValue;\n\t            }\n\t            newValue = adm.makeReactiveArrayItem(newValue);\n\t            var changed = (adm.mode === ValueMode.Structure) ? !deepEquals(oldValue, newValue) : oldValue !== newValue;\n\t            if (changed) {\n\t                values[index] = newValue;\n\t                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n\t            }\n\t        }\n\t        else if (index === values.length) {\n\t            adm.spliceWithArray(index, 0, [newValue]);\n\t        }\n\t        else\n\t            throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n\t    };\n\t}\n\tfunction createArrayGetter(index) {\n\t    return function () {\n\t        var impl = this.$mobx;\n\t        if (impl && index < impl.values.length) {\n\t            impl.atom.reportObserved();\n\t            return impl.values[index];\n\t        }\n\t        return undefined;\n\t    };\n\t}\n\tfunction reserveArrayBuffer(max) {\n\t    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++)\n\t        createArrayBufferItem(index);\n\t    OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n\t}\n\treserveArrayBuffer(1000);\n\tfunction createObservableArray(initialValues, mode, name) {\n\t    return new ObservableArray(initialValues, mode, name);\n\t}\n\tfunction fastArray(initialValues) {\n\t    deprecated(\"fastArray is deprecated. Please use `observable(asFlat([]))`\");\n\t    return createObservableArray(initialValues, ValueMode.Flat, null);\n\t}\n\texports.fastArray = fastArray;\n\tfunction isObservableArray(thing) {\n\t    return thing instanceof ObservableArray;\n\t}\n\texports.isObservableArray = isObservableArray;\n\tvar ObservableMapMarker = {};\n\tvar ObservableMap = (function () {\n\t    function ObservableMap(initialData, valueModeFunc) {\n\t        var _this = this;\n\t        this.$mobx = ObservableMapMarker;\n\t        this._data = {};\n\t        this._hasMap = {};\n\t        this.name = \"ObservableMap@\" + getNextId();\n\t        this._keys = new ObservableArray(null, ValueMode.Reference, this.name + \".keys()\", true);\n\t        this.interceptors = null;\n\t        this.changeListeners = null;\n\t        this._valueMode = getValueModeFromModifierFunc(valueModeFunc);\n\t        if (this._valueMode === ValueMode.Flat)\n\t            this._valueMode = ValueMode.Reference;\n\t        allowStateChanges(true, function () {\n\t            if (isPlainObject(initialData))\n\t                _this.merge(initialData);\n\t            else if (Array.isArray(initialData))\n\t                initialData.forEach(function (_a) {\n\t                    var key = _a[0], value = _a[1];\n\t                    return _this.set(key, value);\n\t                });\n\t        });\n\t    }\n\t    ObservableMap.prototype._has = function (key) {\n\t        return typeof this._data[key] !== \"undefined\";\n\t    };\n\t    ObservableMap.prototype.has = function (key) {\n\t        if (!this.isValidKey(key))\n\t            return false;\n\t        key = \"\" + key;\n\t        if (this._hasMap[key])\n\t            return this._hasMap[key].get();\n\t        return this._updateHasMapEntry(key, false).get();\n\t    };\n\t    ObservableMap.prototype.set = function (key, value) {\n\t        this.assertValidKey(key);\n\t        key = \"\" + key;\n\t        var hasKey = this._has(key);\n\t        assertUnwrapped(value, \"[mobx.map.set] Expected unwrapped value to be inserted to key '\" + key + \"'. If you need to use modifiers pass them as second argument to the constructor\");\n\t        if (hasInterceptors(this)) {\n\t            var change = interceptChange(this, {\n\t                type: hasKey ? \"update\" : \"add\",\n\t                object: this,\n\t                newValue: value,\n\t                name: key\n\t            });\n\t            if (!change)\n\t                return;\n\t            value = change.newValue;\n\t        }\n\t        if (hasKey) {\n\t            this._updateValue(key, value);\n\t        }\n\t        else {\n\t            this._addValue(key, value);\n\t        }\n\t    };\n\t    ObservableMap.prototype.delete = function (key) {\n\t        var _this = this;\n\t        this.assertValidKey(key);\n\t        key = \"\" + key;\n\t        if (hasInterceptors(this)) {\n\t            var change = interceptChange(this, {\n\t                type: \"delete\",\n\t                object: this,\n\t                name: key\n\t            });\n\t            if (!change)\n\t                return;\n\t        }\n\t        if (this._has(key)) {\n\t            var notifySpy = isSpyEnabled();\n\t            var notify = hasListeners(this);\n\t            var change = notify || notifySpy ? {\n\t                type: \"delete\",\n\t                object: this,\n\t                oldValue: this._data[key].value,\n\t                name: key\n\t            } : null;\n\t            if (notifySpy)\n\t                spyReportStart(change);\n\t            transaction(function () {\n\t                _this._keys.remove(key);\n\t                _this._updateHasMapEntry(key, false);\n\t                var observable = _this._data[key];\n\t                observable.setNewValue(undefined);\n\t                _this._data[key] = undefined;\n\t            }, undefined, false);\n\t            if (notify)\n\t                notifyListeners(this, change);\n\t            if (notifySpy)\n\t                spyReportEnd();\n\t        }\n\t    };\n\t    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n\t        var entry = this._hasMap[key];\n\t        if (entry) {\n\t            entry.setNewValue(value);\n\t        }\n\t        else {\n\t            entry = this._hasMap[key] = new ObservableValue(value, ValueMode.Reference, this.name + \".\" + key + \"?\", false);\n\t        }\n\t        return entry;\n\t    };\n\t    ObservableMap.prototype._updateValue = function (name, newValue) {\n\t        var observable = this._data[name];\n\t        newValue = observable.prepareNewValue(newValue);\n\t        if (newValue !== UNCHANGED) {\n\t            var notifySpy = isSpyEnabled();\n\t            var notify = hasListeners(this);\n\t            var change = notify || notifySpy ? {\n\t                type: \"update\",\n\t                object: this,\n\t                oldValue: observable.value,\n\t                name: name, newValue: newValue\n\t            } : null;\n\t            if (notifySpy)\n\t                spyReportStart(change);\n\t            observable.setNewValue(newValue);\n\t            if (notify)\n\t                notifyListeners(this, change);\n\t            if (notifySpy)\n\t                spyReportEnd();\n\t        }\n\t    };\n\t    ObservableMap.prototype._addValue = function (name, newValue) {\n\t        var _this = this;\n\t        transaction(function () {\n\t            var observable = _this._data[name] = new ObservableValue(newValue, _this._valueMode, _this.name + \".\" + name, false);\n\t            newValue = observable.value;\n\t            _this._updateHasMapEntry(name, true);\n\t            _this._keys.push(name);\n\t        }, undefined, false);\n\t        var notifySpy = isSpyEnabled();\n\t        var notify = hasListeners(this);\n\t        var change = notify || notifySpy ? {\n\t            type: \"add\",\n\t            object: this,\n\t            name: name, newValue: newValue\n\t        } : null;\n\t        if (notifySpy)\n\t            spyReportStart(change);\n\t        if (notify)\n\t            notifyListeners(this, change);\n\t        if (notifySpy)\n\t            spyReportEnd();\n\t    };\n\t    ObservableMap.prototype.get = function (key) {\n\t        key = \"\" + key;\n\t        if (this.has(key))\n\t            return this._data[key].get();\n\t        return undefined;\n\t    };\n\t    ObservableMap.prototype.keys = function () {\n\t        return this._keys.slice();\n\t    };\n\t    ObservableMap.prototype.values = function () {\n\t        return this.keys().map(this.get, this);\n\t    };\n\t    ObservableMap.prototype.entries = function () {\n\t        var _this = this;\n\t        return this.keys().map(function (key) { return [key, _this.get(key)]; });\n\t    };\n\t    ObservableMap.prototype.forEach = function (callback, thisArg) {\n\t        var _this = this;\n\t        this.keys().forEach(function (key) { return callback.call(thisArg, _this.get(key), key); });\n\t    };\n\t    ObservableMap.prototype.merge = function (other) {\n\t        var _this = this;\n\t        transaction(function () {\n\t            if (other instanceof ObservableMap)\n\t                other.keys().forEach(function (key) { return _this.set(key, other.get(key)); });\n\t            else\n\t                Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });\n\t        }, undefined, false);\n\t        return this;\n\t    };\n\t    ObservableMap.prototype.clear = function () {\n\t        var _this = this;\n\t        transaction(function () {\n\t            untracked(function () {\n\t                _this.keys().forEach(_this.delete, _this);\n\t            });\n\t        }, undefined, false);\n\t    };\n\t    Object.defineProperty(ObservableMap.prototype, \"size\", {\n\t        get: function () {\n\t            return this._keys.length;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ObservableMap.prototype.toJS = function () {\n\t        var _this = this;\n\t        var res = {};\n\t        this.keys().forEach(function (key) { return res[key] = _this.get(key); });\n\t        return res;\n\t    };\n\t    ObservableMap.prototype.toJs = function () {\n\t        deprecated(\"toJs is deprecated, use toJS instead\");\n\t        return this.toJS();\n\t    };\n\t    ObservableMap.prototype.toJSON = function () {\n\t        return this.toJS();\n\t    };\n\t    ObservableMap.prototype.isValidKey = function (key) {\n\t        if (key === null || key === undefined)\n\t            return false;\n\t        if (typeof key !== \"string\" && typeof key !== \"number\" && typeof key !== \"boolean\")\n\t            return false;\n\t        return true;\n\t    };\n\t    ObservableMap.prototype.assertValidKey = function (key) {\n\t        if (!this.isValidKey(key))\n\t            throw new Error(\"[mobx.map] Invalid key: '\" + key + \"'\");\n\t    };\n\t    ObservableMap.prototype.toString = function () {\n\t        var _this = this;\n\t        return this.name + \"[{ \" + this.keys().map(function (key) { return (key + \": \" + (\"\" + _this.get(key))); }).join(\", \") + \" }]\";\n\t    };\n\t    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n\t        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable maps.\");\n\t        return registerListener(this, listener);\n\t    };\n\t    ObservableMap.prototype.intercept = function (handler) {\n\t        return registerInterceptor(this, handler);\n\t    };\n\t    return ObservableMap;\n\t}());\n\texports.ObservableMap = ObservableMap;\n\tfunction map(initialValues, valueModifier) {\n\t    return new ObservableMap(initialValues, valueModifier);\n\t}\n\texports.map = map;\n\tfunction isObservableMap(thing) {\n\t    return thing instanceof ObservableMap;\n\t}\n\texports.isObservableMap = isObservableMap;\n\tvar ObservableObjectAdministration = (function () {\n\t    function ObservableObjectAdministration(target, name, mode) {\n\t        this.target = target;\n\t        this.name = name;\n\t        this.mode = mode;\n\t        this.values = {};\n\t        this.changeListeners = null;\n\t        this.interceptors = null;\n\t    }\n\t    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n\t        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n\t        return registerListener(this, callback);\n\t    };\n\t    ObservableObjectAdministration.prototype.intercept = function (handler) {\n\t        return registerInterceptor(this, handler);\n\t    };\n\t    return ObservableObjectAdministration;\n\t}());\n\tfunction asObservableObject(target, name, mode) {\n\t    if (mode === void 0) { mode = ValueMode.Recursive; }\n\t    if (isObservableObject(target))\n\t        return target.$mobx;\n\t    if (!isPlainObject(target))\n\t        name = target.constructor.name + \"@\" + getNextId();\n\t    if (!name)\n\t        name = \"ObservableObject@\" + getNextId();\n\t    var adm = new ObservableObjectAdministration(target, name, mode);\n\t    Object.defineProperty(target, \"$mobx\", {\n\t        enumerable: false,\n\t        configurable: false,\n\t        writable: false,\n\t        value: adm\n\t    });\n\t    return adm;\n\t}\n\tfunction setObservableObjectInstanceProperty(adm, propName, value) {\n\t    if (adm.values[propName])\n\t        adm.target[propName] = value;\n\t    else\n\t        defineObservableProperty(adm, propName, value, true);\n\t}\n\tfunction defineObservableProperty(adm, propName, newValue, asInstanceProperty) {\n\t    if (asInstanceProperty)\n\t        assertPropertyConfigurable(adm.target, propName);\n\t    var observable;\n\t    var name = adm.name + \".\" + propName;\n\t    var isComputed = true;\n\t    if (typeof newValue === \"function\" && newValue.length === 0 && !isAction(newValue))\n\t        observable = new ComputedValue(newValue, adm.target, false, name);\n\t    else if (newValue instanceof AsStructure && typeof newValue.value === \"function\" && newValue.value.length === 0)\n\t        observable = new ComputedValue(newValue.value, adm.target, true, name);\n\t    else {\n\t        isComputed = false;\n\t        if (hasInterceptors(adm)) {\n\t            var change = interceptChange(adm, {\n\t                object: adm.target,\n\t                name: propName,\n\t                type: \"add\",\n\t                newValue: newValue\n\t            });\n\t            if (!change)\n\t                return;\n\t            newValue = change.newValue;\n\t        }\n\t        observable = new ObservableValue(newValue, adm.mode, name, false);\n\t        newValue = observable.value;\n\t    }\n\t    adm.values[propName] = observable;\n\t    if (asInstanceProperty) {\n\t        Object.defineProperty(adm.target, propName, {\n\t            configurable: true,\n\t            enumerable: !isComputed,\n\t            get: function () {\n\t                return observable.get();\n\t            },\n\t            set: isComputed\n\t                ? throwingComputedValueSetter\n\t                : function (v) {\n\t                    setPropertyValue(this, propName, v);\n\t                }\n\t        });\n\t    }\n\t    if (!isComputed)\n\t        notifyPropertyAddition(adm, adm.target, propName, newValue);\n\t}\n\tfunction setPropertyValue(instance, name, newValue) {\n\t    var adm = instance.$mobx;\n\t    var observable = instance.$mobx.values[name];\n\t    if (hasInterceptors(adm)) {\n\t        var change = interceptChange(adm, {\n\t            type: \"update\",\n\t            object: instance,\n\t            name: name, newValue: newValue\n\t        });\n\t        if (!change)\n\t            return;\n\t        newValue = change.newValue;\n\t    }\n\t    newValue = observable.prepareNewValue(newValue);\n\t    if (newValue !== UNCHANGED) {\n\t        var notify = hasListeners(adm);\n\t        var notifySpy = isSpyEnabled();\n\t        var change = notifyListeners || hasListeners ? {\n\t            type: \"update\",\n\t            object: instance,\n\t            oldValue: observable.value,\n\t            name: name, newValue: newValue\n\t        } : null;\n\t        if (notifySpy)\n\t            spyReportStart(change);\n\t        observable.setNewValue(newValue);\n\t        if (notify)\n\t            notifyListeners(adm, change);\n\t        if (notifySpy)\n\t            spyReportEnd();\n\t    }\n\t}\n\tfunction notifyPropertyAddition(adm, object, name, newValue) {\n\t    var notify = hasListeners(adm);\n\t    var notifySpy = isSpyEnabled();\n\t    var change = notify || notifySpy ? {\n\t        type: \"add\",\n\t        object: object, name: name, newValue: newValue\n\t    } : null;\n\t    if (notifySpy)\n\t        spyReportStart(change);\n\t    if (notify)\n\t        notifyListeners(adm, change);\n\t    if (notifySpy)\n\t        spyReportEnd();\n\t}\n\tfunction isObservableObject(thing) {\n\t    if (typeof thing === \"object\" && thing !== null) {\n\t        runLazyInitializers(thing);\n\t        return thing.$mobx instanceof ObservableObjectAdministration;\n\t    }\n\t    return false;\n\t}\n\texports.isObservableObject = isObservableObject;\n\tvar UNCHANGED = {};\n\tvar ObservableValue = (function (_super) {\n\t    __extends(ObservableValue, _super);\n\t    function ObservableValue(value, mode, name, notifySpy) {\n\t        if (name === void 0) { name = \"ObservableValue@\" + getNextId(); }\n\t        if (notifySpy === void 0) { notifySpy = true; }\n\t        _super.call(this, name);\n\t        this.mode = mode;\n\t        this.hasUnreportedChange = false;\n\t        this.value = undefined;\n\t        var _a = getValueModeFromValue(value, ValueMode.Recursive), childmode = _a[0], unwrappedValue = _a[1];\n\t        if (this.mode === ValueMode.Recursive)\n\t            this.mode = childmode;\n\t        this.value = makeChildObservable(unwrappedValue, this.mode, this.name);\n\t        if (notifySpy && isSpyEnabled()) {\n\t            spyReport({ type: \"create\", object: this, newValue: this.value });\n\t        }\n\t    }\n\t    ObservableValue.prototype.set = function (newValue) {\n\t        var oldValue = this.value;\n\t        newValue = this.prepareNewValue(newValue);\n\t        if (newValue !== UNCHANGED) {\n\t            var notifySpy = isSpyEnabled();\n\t            if (notifySpy) {\n\t                spyReportStart({\n\t                    type: \"update\",\n\t                    object: this,\n\t                    newValue: newValue, oldValue: oldValue\n\t                });\n\t            }\n\t            this.setNewValue(newValue);\n\t            if (notifySpy)\n\t                spyReportEnd();\n\t        }\n\t    };\n\t    ObservableValue.prototype.prepareNewValue = function (newValue) {\n\t        assertUnwrapped(newValue, \"Modifiers cannot be used on non-initial values.\");\n\t        checkIfStateModificationsAreAllowed();\n\t        if (hasInterceptors(this)) {\n\t            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n\t            if (!change)\n\t                return UNCHANGED;\n\t            newValue = change.newValue;\n\t        }\n\t        var changed = valueDidChange(this.mode === ValueMode.Structure, this.value, newValue);\n\t        if (changed)\n\t            return makeChildObservable(newValue, this.mode, this.name);\n\t        return UNCHANGED;\n\t    };\n\t    ObservableValue.prototype.setNewValue = function (newValue) {\n\t        var oldValue = this.value;\n\t        this.value = newValue;\n\t        this.reportChanged();\n\t        if (hasListeners(this))\n\t            notifyListeners(this, [newValue, oldValue]);\n\t    };\n\t    ObservableValue.prototype.get = function () {\n\t        this.reportObserved();\n\t        return this.value;\n\t    };\n\t    ObservableValue.prototype.intercept = function (handler) {\n\t        return registerInterceptor(this, handler);\n\t    };\n\t    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n\t        if (fireImmediately)\n\t            listener(this.value, undefined);\n\t        return registerListener(this, listener);\n\t    };\n\t    ObservableValue.prototype.toJSON = function () {\n\t        return this.get();\n\t    };\n\t    ObservableValue.prototype.toString = function () {\n\t        return this.name + \"[\" + this.value + \"]\";\n\t    };\n\t    return ObservableValue;\n\t}(Atom));\n\tfunction getAtom(thing, property) {\n\t    if (typeof thing === \"object\" && thing !== null) {\n\t        if (isObservableArray(thing)) {\n\t            invariant(property === undefined, \"It is not possible to get index atoms from arrays\");\n\t            return thing.$mobx.atom;\n\t        }\n\t        if (isObservableMap(thing)) {\n\t            if (property === undefined)\n\t                return getAtom(thing._keys);\n\t            var observable_1 = thing._data[property] || thing._hasMap[property];\n\t            invariant(!!observable_1, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n\t            return observable_1;\n\t        }\n\t        runLazyInitializers(thing);\n\t        if (isObservableObject(thing)) {\n\t            invariant(!!property, \"please specify a property\");\n\t            var observable_2 = thing.$mobx.values[property];\n\t            invariant(!!observable_2, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n\t            return observable_2;\n\t        }\n\t        if (thing instanceof Atom || thing instanceof ComputedValue || thing instanceof Reaction) {\n\t            return thing;\n\t        }\n\t    }\n\t    else if (typeof thing === \"function\") {\n\t        if (thing.$mobx instanceof Reaction) {\n\t            return thing.$mobx;\n\t        }\n\t    }\n\t    invariant(false, \"Cannot obtain atom from \" + thing);\n\t}\n\tfunction getAdministration(thing, property) {\n\t    invariant(thing, \"Expection some object\");\n\t    if (property !== undefined)\n\t        return getAdministration(getAtom(thing, property));\n\t    if (thing instanceof Atom || thing instanceof ComputedValue || thing instanceof Reaction)\n\t        return thing;\n\t    if (isObservableMap(thing))\n\t        return thing;\n\t    runLazyInitializers(thing);\n\t    if (thing.$mobx)\n\t        return thing.$mobx;\n\t    invariant(false, \"Cannot obtain administration from \" + thing);\n\t}\n\tfunction getDebugName(thing, property) {\n\t    var named;\n\t    if (property !== undefined)\n\t        named = getAtom(thing, property);\n\t    else if (isObservableObject(thing) || isObservableMap(thing))\n\t        named = getAdministration(thing);\n\t    else\n\t        named = getAtom(thing);\n\t    return named.name;\n\t}\n\tfunction createClassPropertyDecorator(onInitialize, get, set, enumerable, allowCustomArguments) {\n\t    function classPropertyDecorator(target, key, descriptor, customArgs) {\n\t        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n\t        if (!descriptor) {\n\t            return {\n\t                enumerable: enumerable,\n\t                configurable: true,\n\t                get: function () {\n\t                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true)\n\t                        typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n\t                    return get.call(this, key);\n\t                },\n\t                set: function (v) {\n\t                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n\t                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n\t                    }\n\t                    else {\n\t                        set.call(this, key, v);\n\t                    }\n\t                }\n\t            };\n\t        }\n\t        else {\n\t            if (!target.hasOwnProperty(\"__mobxLazyInitializers\")) {\n\t                Object.defineProperty(target, \"__mobxLazyInitializers\", {\n\t                    writable: false, configurable: false, enumerable: false,\n\t                    value: (target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice()) || []\n\t                });\n\t            }\n\t            var value_1 = descriptor.value, initializer_1 = descriptor.initializer;\n\t            target.__mobxLazyInitializers.push(function (instance) {\n\t                onInitialize(instance, key, (initializer_1 ? initializer_1.call(instance) : value_1), customArgs, descriptor);\n\t            });\n\t            return {\n\t                enumerable: enumerable, configurable: true,\n\t                get: function () {\n\t                    if (this.__mobxDidRunLazyInitializers !== true)\n\t                        runLazyInitializers(this);\n\t                    return get.call(this, key);\n\t                },\n\t                set: function (v) {\n\t                    if (this.__mobxDidRunLazyInitializers !== true)\n\t                        runLazyInitializers(this);\n\t                    set.call(this, key, v);\n\t                }\n\t            };\n\t        }\n\t    }\n\t    if (allowCustomArguments) {\n\t        return function () {\n\t            if (quacksLikeADecorator(arguments))\n\t                return classPropertyDecorator.apply(null, arguments);\n\t            var outerArgs = arguments;\n\t            return function (target, key, descriptor) { return classPropertyDecorator(target, key, descriptor, outerArgs); };\n\t        };\n\t    }\n\t    return classPropertyDecorator;\n\t}\n\tfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n\t    if (!instance.hasOwnProperty(\"__mobxInitializedProps\")) {\n\t        Object.defineProperty(instance, \"__mobxInitializedProps\", {\n\t            enumerable: false, configurable: false, writable: true,\n\t            value: {}\n\t        });\n\t    }\n\t    instance.__mobxInitializedProps[key] = true;\n\t    onInitialize(instance, key, v, customArgs, baseDescriptor);\n\t}\n\tfunction runLazyInitializers(instance) {\n\t    if (instance.__mobxDidRunLazyInitializers === true)\n\t        return;\n\t    if (instance.__mobxLazyInitializers) {\n\t        Object.defineProperty(instance, \"__mobxDidRunLazyInitializers\", {\n\t            enumerable: false,\n\t            configurable: false,\n\t            writable: false,\n\t            value: true\n\t        });\n\t        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) { return initializer(instance); });\n\t    }\n\t}\n\tfunction quacksLikeADecorator(args) {\n\t    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n\t}\n\tvar SimpleEventEmitter = (function () {\n\t    function SimpleEventEmitter() {\n\t        this.listeners = [];\n\t        deprecated(\"extras.SimpleEventEmitter is deprecated and will be removed in the next major release\");\n\t    }\n\t    SimpleEventEmitter.prototype.emit = function () {\n\t        var listeners = this.listeners.slice();\n\t        for (var i = 0, l = listeners.length; i < l; i++)\n\t            listeners[i].apply(null, arguments);\n\t    };\n\t    SimpleEventEmitter.prototype.on = function (listener) {\n\t        var _this = this;\n\t        this.listeners.push(listener);\n\t        return once(function () {\n\t            var idx = _this.listeners.indexOf(listener);\n\t            if (idx !== -1)\n\t                _this.listeners.splice(idx, 1);\n\t        });\n\t    };\n\t    SimpleEventEmitter.prototype.once = function (listener) {\n\t        var subscription = this.on(function () {\n\t            subscription();\n\t            listener.apply(this, arguments);\n\t        });\n\t        return subscription;\n\t    };\n\t    return SimpleEventEmitter;\n\t}());\n\texports.SimpleEventEmitter = SimpleEventEmitter;\n\tvar EMPTY_ARRAY = [];\n\tObject.freeze(EMPTY_ARRAY);\n\tfunction getNextId() {\n\t    return ++globalState.mobxGuid;\n\t}\n\tfunction invariant(check, message, thing) {\n\t    if (!check)\n\t        throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n\t}\n\tvar deprecatedMessages = [];\n\tfunction deprecated(msg) {\n\t    if (deprecatedMessages.indexOf(msg) !== -1)\n\t        return;\n\t    deprecatedMessages.push(msg);\n\t    console.error(\"[mobx] Deprecated: \" + msg);\n\t}\n\tfunction once(func) {\n\t    var invoked = false;\n\t    return function () {\n\t        if (invoked)\n\t            return;\n\t        invoked = true;\n\t        return func.apply(this, arguments);\n\t    };\n\t}\n\tvar noop = function () { };\n\tfunction unique(list) {\n\t    var res = [];\n\t    list.forEach(function (item) {\n\t        if (res.indexOf(item) === -1)\n\t            res.push(item);\n\t    });\n\t    return res;\n\t}\n\tfunction joinStrings(things, limit, separator) {\n\t    if (limit === void 0) { limit = 100; }\n\t    if (separator === void 0) { separator = \" - \"; }\n\t    if (!things)\n\t        return \"\";\n\t    var sliced = things.slice(0, limit);\n\t    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n\t}\n\tfunction isPlainObject(value) {\n\t    return value !== null && typeof value === \"object\" && Object.getPrototypeOf(value) === Object.prototype;\n\t}\n\tfunction objectAssign() {\n\t    var res = arguments[0];\n\t    for (var i = 1, l = arguments.length; i < l; i++) {\n\t        var source = arguments[i];\n\t        for (var key in source)\n\t            if (source.hasOwnProperty(key)) {\n\t                res[key] = source[key];\n\t            }\n\t    }\n\t    return res;\n\t}\n\tfunction valueDidChange(compareStructural, oldValue, newValue) {\n\t    return compareStructural\n\t        ? !deepEquals(oldValue, newValue)\n\t        : oldValue !== newValue;\n\t}\n\tfunction makeNonEnumerable(object, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t        Object.defineProperty(object, props[i], {\n\t            configurable: true,\n\t            writable: true,\n\t            enumerable: false,\n\t            value: object[props[i]]\n\t        });\n\t    }\n\t}\n\tfunction isPropertyConfigurable(object, prop) {\n\t    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n\t    return !descriptor || (descriptor.configurable !== false && descriptor.writable !== false);\n\t}\n\tfunction assertPropertyConfigurable(object, prop) {\n\t    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n\t}\n\tfunction getEnumerableKeys(obj) {\n\t    var res = [];\n\t    for (var key in obj)\n\t        res.push(key);\n\t    return res;\n\t}\n\tfunction deepEquals(a, b) {\n\t    if (a === null && b === null)\n\t        return true;\n\t    if (a === undefined && b === undefined)\n\t        return true;\n\t    var aIsArray = Array.isArray(a) || isObservableArray(a);\n\t    if (aIsArray !== (Array.isArray(b) || isObservableArray(b))) {\n\t        return false;\n\t    }\n\t    else if (aIsArray) {\n\t        if (a.length !== b.length)\n\t            return false;\n\t        for (var i = a.length; i >= 0; i--)\n\t            if (!deepEquals(a[i], b[i]))\n\t                return false;\n\t        return true;\n\t    }\n\t    else if (typeof a === \"object\" && typeof b === \"object\") {\n\t        if (a === null || b === null)\n\t            return false;\n\t        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length)\n\t            return false;\n\t        for (var prop in a) {\n\t            if (!(prop in b))\n\t                return false;\n\t            if (!deepEquals(a[prop], b[prop]))\n\t                return false;\n\t        }\n\t        return true;\n\t    }\n\t    return a === b;\n\t}\n\tfunction quickDiff(current, base) {\n\t    if (!base || !base.length)\n\t        return [current, []];\n\t    if (!current || !current.length)\n\t        return [[], base];\n\t    var added = [];\n\t    var removed = [];\n\t    var currentIndex = 0, currentSearch = 0, currentLength = current.length, currentExhausted = false, baseIndex = 0, baseSearch = 0, baseLength = base.length, isSearching = false, baseExhausted = false;\n\t    while (!baseExhausted && !currentExhausted) {\n\t        if (!isSearching) {\n\t            if (currentIndex < currentLength && baseIndex < baseLength && current[currentIndex] === base[baseIndex]) {\n\t                currentIndex++;\n\t                baseIndex++;\n\t                if (currentIndex === currentLength && baseIndex === baseLength)\n\t                    return [added, removed];\n\t                continue;\n\t            }\n\t            currentSearch = currentIndex;\n\t            baseSearch = baseIndex;\n\t            isSearching = true;\n\t        }\n\t        baseSearch += 1;\n\t        currentSearch += 1;\n\t        if (baseSearch >= baseLength)\n\t            baseExhausted = true;\n\t        if (currentSearch >= currentLength)\n\t            currentExhausted = true;\n\t        if (!currentExhausted && current[currentSearch] === base[baseIndex]) {\n\t            added = added.concat(current.slice(currentIndex, currentSearch));\n\t            currentIndex = currentSearch + 1;\n\t            baseIndex++;\n\t            isSearching = false;\n\t        }\n\t        else if (!baseExhausted && base[baseSearch] === current[currentIndex]) {\n\t            removed = removed.concat(base.slice(baseIndex, baseSearch));\n\t            baseIndex = baseSearch + 1;\n\t            currentIndex++;\n\t            isSearching = false;\n\t        }\n\t    }\n\t    return [\n\t        added.concat(current.slice(currentIndex)),\n\t        removed.concat(base.slice(baseIndex))\n\t    ];\n\t}\n\tvar _a;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** app.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 308800d3c7c031a6d090\n **/","import {autorun, observable}  from 'mobx';\n\nlet CounterStore = observable({\n  counter: 0,\n});\n\nconst render = () => {\n  document.getElementById('counter').innerHTML = CounterStore.counter;\n};\n\nautorun(render);\n\nwindow.plusClick = () => {\n  CounterStore.counter++;\n};\n\nwindow.minusClick = () => {\n  CounterStore.counter--;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/app.js\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    resetGlobalState: resetGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    trackTransitions: trackTransitions\n};\nexports._ = {\n    getAdministration: getAdministration,\n    quickDiff: quickDiff,\n    resetGlobalState: resetGlobalState\n};\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    }\n    else if (typeof arg1 === \"function\") {\n        name = arg1.name || (\"Autorun@\" + getNextId());\n        view = arg1;\n        scope = arg2;\n    }\n    assertUnwrapped(view, \"autorun methods cannot have modifiers\");\n    invariant(typeof view === \"function\", \"autorun expects a function\");\n    invariant(view.length === 0, \"autorun expects a function without arguments\");\n    if (scope)\n        view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(view);\n    });\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    }\n    else if (typeof arg1 === \"function\") {\n        name = (\"When@\" + getNextId());\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposeImmediately = false;\n    var disposer = autorun(name, function () {\n        if (predicate.call(scope)) {\n            if (disposer)\n                disposer();\n            else\n                disposeImmediately = true;\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    if (disposeImmediately)\n        disposer();\n    return disposer;\n}\nexports.when = when;\nfunction autorunUntil(predicate, effect, scope) {\n    deprecated(\"`autorunUntil` is deprecated, please use `when`.\");\n    return when.apply(null, arguments);\n}\nexports.autorunUntil = autorunUntil;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    }\n    else if (typeof arg1 === \"function\") {\n        name = arg1.name || (\"AutorunAsync@\" + getNextId());\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    if (delay === void 0)\n        delay = 1;\n    if (scope)\n        func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed)\n                    r.track(func);\n            }, delay);\n        }\n    });\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(arg1, arg2, arg3, arg4, arg5, arg6) {\n    var name, expression, effect, fireImmediately, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        expression = arg2;\n        effect = arg3;\n        fireImmediately = arg4;\n        delay = arg5;\n        scope = arg6;\n    }\n    else {\n        name = arg1.name || arg2.name || (\"Reaction@\" + getNextId());\n        expression = arg1;\n        effect = arg2;\n        fireImmediately = arg3;\n        delay = arg4;\n        scope = arg5;\n    }\n    if (fireImmediately === void 0)\n        fireImmediately = false;\n    if (delay === void 0)\n        delay = 0;\n    var _a = getValueModeFromValue(expression, ValueMode.Reference), valueMode = _a[0], unwrappedExpression = _a[1];\n    var compareStructural = valueMode === ValueMode.Structure;\n    if (scope) {\n        unwrappedExpression = unwrappedExpression.bind(scope);\n        effect = action(name, effect.bind(scope));\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue = undefined;\n    function reactionRunner() {\n        if (r.isDisposed)\n            return;\n        var changed = false;\n        r.track(function () {\n            var v = unwrappedExpression();\n            changed = valueDidChange(compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && fireImmediately)\n            effect(nextValue);\n        if (!firstTime && changed === true)\n            effect(nextValue);\n        if (firstTime)\n            firstTime = false;\n    }\n    var r = new Reaction(name, function () {\n        if (delay < 1) {\n            reactionRunner();\n        }\n        else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, delay);\n        }\n    });\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nvar computedDecorator = createClassPropertyDecorator(function (target, name, _, decoratorArgs, originalDescriptor) {\n    var baseValue = originalDescriptor.get;\n    invariant(typeof baseValue === \"function\", \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\");\n    var compareStructural = false;\n    if (decoratorArgs && decoratorArgs.length === 1 && decoratorArgs[0].asStructure === true)\n        compareStructural = true;\n    var adm = asObservableObject(target, undefined, ValueMode.Recursive);\n    defineObservableProperty(adm, name, compareStructural ? asStructure(baseValue) : baseValue, false);\n}, function (name) {\n    return this.$mobx.values[name].get();\n}, throwingComputedValueSetter, false, true);\nfunction computed(targetOrExpr, keyOrScope, baseDescriptor, options) {\n    if (arguments.length < 3 && typeof targetOrExpr === \"function\")\n        return computedExpr(targetOrExpr, keyOrScope);\n    invariant(!baseDescriptor || !baseDescriptor.set, \"@observable properties cannot have a setter: \" + keyOrScope);\n    return computedDecorator.apply(null, arguments);\n}\nexports.computed = computed;\nfunction computedExpr(expr, scope) {\n    var _a = getValueModeFromValue(expr, ValueMode.Recursive), mode = _a[0], value = _a[1];\n    return new ComputedValue(value, scope, mode === ValueMode.Structure, value.name);\n}\nfunction throwingComputedValueSetter() {\n    throw new Error(\"[ComputedValue] It is not allowed to assign new values to computed properties.\");\n}\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length === 1, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = (function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            _super.call(this, function () { return transformer(sourceObject); }, null, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier);\n            this.sourceIdentifier = sourceIdentifier;\n            this.sourceObject = sourceObject;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup)\n                onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue));\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer)\n            return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || typeof object !== \"object\")\n        throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        Object.defineProperty(object, \"$transformId\", {\n            configurable: true,\n            writable: true,\n            enumerable: false,\n            value: tid\n        });\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation())\n        console.warn(\"[mobx.expr] 'expr' should only be used inside other reactive functions.\");\n    return computed(expr, scope).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    invariant(arguments.length >= 2, \"extendObservable expected 2 or more arguments\");\n    invariant(typeof target === \"object\", \"extendObservable expects an object as first argument\");\n    invariant(!(target instanceof ObservableMap), \"extendObservable should not be used on maps, use map.merge instead\");\n    properties.forEach(function (propSet) {\n        invariant(typeof propSet === \"object\", \"all arguments of extendObservable should be objects\");\n        extendObservableHelper(target, propSet, ValueMode.Recursive, null);\n    });\n    return target;\n}\nexports.extendObservable = extendObservable;\nfunction extendObservableHelper(target, properties, mode, name) {\n    var adm = asObservableObject(target, name, mode);\n    for (var key in properties)\n        if (properties.hasOwnProperty(key)) {\n            if (target === properties && !isPropertyConfigurable(target, key))\n                continue;\n            setObservableObjectInstanceProperty(adm, key, properties[key]);\n        }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length)\n        result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observers && node.observers.length)\n        result.observers = unique(node.observers).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\")\n        return interceptProperty(thing, propOrHandler, handler);\n    else\n        return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    if (isPlainObject(thing) && !isObservableObject(thing)) {\n        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n        return getAdministration(observable(thing)).intercept(handler);\n    }\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    if (isPlainObject(thing) && !isObservableObject(thing)) {\n        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n        extendObservable(thing, {\n            property: thing[property]\n        });\n        return interceptProperty(thing, property, handler);\n    }\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isObservable(value, property) {\n    if (value === null || value === undefined)\n        return false;\n    if (property !== undefined) {\n        if (value instanceof ObservableMap || value instanceof ObservableArray)\n            throw new Error(\"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\");\n        else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return !!value.$mobx || value instanceof Atom || value instanceof Reaction || value instanceof ComputedValue;\n}\nexports.isObservable = isObservable;\nvar decoratorImpl = createClassPropertyDecorator(function (target, name, baseValue) {\n    var prevA = allowStateChangesStart(true);\n    if (typeof baseValue === \"function\")\n        baseValue = asReference(baseValue);\n    var adm = asObservableObject(target, undefined, ValueMode.Recursive);\n    defineObservableProperty(adm, name, baseValue, false);\n    allowStateChangesEnd(prevA);\n}, function (name) {\n    return this.$mobx.values[name].get();\n}, function (name, value) {\n    setPropertyValue(this, name, value);\n}, true, false);\nfunction observableDecorator(target, key, baseDescriptor) {\n    invariant(arguments.length >= 2 && arguments.length <= 3, \"Illegal decorator config\", key);\n    assertPropertyConfigurable(target, key);\n    invariant(!baseDescriptor || !baseDescriptor.get, \"@observable can not be used on getters, use @computed instead\");\n    return decoratorImpl.apply(null, arguments);\n}\nfunction observable(v, keyOrScope) {\n    if (v === void 0) { v = undefined; }\n    if (typeof arguments[1] === \"string\")\n        return observableDecorator.apply(null, arguments);\n    invariant(arguments.length < 3, \"observable expects zero, one or two arguments\");\n    if (isObservable(v))\n        return v;\n    var _a = getValueModeFromValue(v, ValueMode.Recursive), mode = _a[0], value = _a[1];\n    var sourceType = mode === ValueMode.Reference ? ValueType.Reference : getTypeOfValue(value);\n    switch (sourceType) {\n        case ValueType.Array:\n        case ValueType.PlainObject:\n            return makeChildObservable(value, mode);\n        case ValueType.Reference:\n        case ValueType.ComplexObject:\n            return new ObservableValue(value, mode);\n        case ValueType.ComplexFunction:\n            throw new Error(\"[mobx.observable] To be able to make a function reactive it should not have arguments. If you need an observable reference to a function, use `observable(asReference(f))`\");\n        case ValueType.ViewFunction:\n            deprecated(\"Use `computed(expr)` instead of `observable(expr)`\");\n            return computed(v, keyOrScope);\n    }\n    invariant(false, \"Illegal State\");\n}\nexports.observable = observable;\nvar ValueType;\n(function (ValueType) {\n    ValueType[ValueType[\"Reference\"] = 0] = \"Reference\";\n    ValueType[ValueType[\"PlainObject\"] = 1] = \"PlainObject\";\n    ValueType[ValueType[\"ComplexObject\"] = 2] = \"ComplexObject\";\n    ValueType[ValueType[\"Array\"] = 3] = \"Array\";\n    ValueType[ValueType[\"ViewFunction\"] = 4] = \"ViewFunction\";\n    ValueType[ValueType[\"ComplexFunction\"] = 5] = \"ComplexFunction\";\n})(ValueType || (ValueType = {}));\nfunction getTypeOfValue(value) {\n    if (value === null || value === undefined)\n        return ValueType.Reference;\n    if (typeof value === \"function\")\n        return value.length ? ValueType.ComplexFunction : ValueType.ViewFunction;\n    if (Array.isArray(value) || value instanceof ObservableArray)\n        return ValueType.Array;\n    if (typeof value === \"object\")\n        return isPlainObject(value) ? ValueType.PlainObject : ValueType.ComplexObject;\n    return ValueType.Reference;\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\")\n        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);\n    else\n        return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    if (isPlainObject(thing) && !isObservableObject(thing)) {\n        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n        return getAdministration(observable(thing)).observe(listener, fireImmediately);\n    }\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    if (isPlainObject(thing) && !isObservableObject(thing)) {\n        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n        extendObservable(thing, {\n            property: thing[property]\n        });\n        return observeObservableProperty(thing, property, listener, fireImmediately);\n    }\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) { detectCycles = true; }\n    if (__alreadySeen === void 0) { __alreadySeen = null; }\n    function cache(value) {\n        if (detectCycles)\n            __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (detectCycles && __alreadySeen === null)\n        __alreadySeen = [];\n    if (detectCycles && source !== null && typeof source === \"object\") {\n        for (var i = 0, l = __alreadySeen.length; i < l; i++)\n            if (__alreadySeen[i][0] === source)\n                return __alreadySeen[i][1];\n    }\n    if (!source)\n        return source;\n    if (Array.isArray(source) || source instanceof ObservableArray) {\n        var res = cache([]);\n        var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); });\n        res.length = toAdd.length;\n        for (var i = 0, l = toAdd.length; i < l; i++)\n            res[i] = toAdd[i];\n        return res;\n    }\n    if (source instanceof ObservableMap) {\n        var res_1 = cache({});\n        source.forEach(function (value, key) { return res_1[key] = toJS(value, detectCycles, __alreadySeen); });\n        return res_1;\n    }\n    if (isObservable(source) && source.$mobx instanceof ObservableValue)\n        return toJS(source(), detectCycles, __alreadySeen);\n    if (source instanceof ObservableValue)\n        return toJS(source.get(), detectCycles, __alreadySeen);\n    if (typeof source === \"object\") {\n        var res = cache({});\n        for (var key in source)\n            res[key] = toJS(source[key], detectCycles, __alreadySeen);\n        return res;\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction toJSON(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) { detectCycles = true; }\n    if (__alreadySeen === void 0) { __alreadySeen = null; }\n    deprecated(\"toJSON is deprecated. Use toJS instead\");\n    return toJS.apply(null, arguments);\n}\nexports.toJSON = toJSON;\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.derivationStack[globalState.derivationStack.length - 1];\n            if (!thing)\n                return log(\"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested it's value.\");\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (thing instanceof ComputedValue)\n        return log(thing.whyRun());\n    else if (thing instanceof Reaction)\n        return log(thing.whyRun());\n    else\n        invariant(false, \"whyRun can only be used on reactions and computed values\");\n}\nexports.whyRun = whyRun;\nvar actionDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = (args && args.length === 1) ? args[0] : (value.name || key || \"<unnamed action>\");\n    var wrappedAction = action(actionName, value);\n    if (originalDescriptor && originalDescriptor.value && target.constructor && target.constructor.prototype) {\n        Object.defineProperty(target.constructor.prototype, key, {\n            configurable: true, enumerable: false, writable: false,\n            value: wrappedAction\n        });\n    }\n    else {\n        Object.defineProperty(target, key, {\n            configurable: true, enumerable: false, writable: false,\n            value: wrappedAction\n        });\n    }\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, \"It is not allowed to assign new values to @action fields\");\n}, false, true);\nfunction action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\")\n        return actionImplementation(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\")\n        return actionImplementation(arg1, arg2);\n    return actionDecorator.apply(null, arguments);\n}\nexports.action = action;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", \"`runInAction` expects a function\");\n    invariant(fn.length === 0, \"`runInAction` expects a function without arguments\");\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeWrapped(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction actionImplementation(actionName, fn) {\n    invariant(typeof fn === \"function\", \"`action` can only be invoked on functions\");\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function () {\n        return executeWrapped(actionName, fn, this, arguments);\n    };\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeWrapped(actionName, fn, scope, args) {\n    var ds = globalState.derivationStack;\n    invariant(!(ds[ds.length - 1] instanceof ComputedValue), \"Computed values or transformers should not invoke actions or trigger other side effects\");\n    var notifySpy = isSpyEnabled();\n    var startTime;\n    if (notifySpy) {\n        startTime = Date.now();\n        var flattendArgs = [];\n        for (var i = 0, l = args.length; i < l; i++)\n            flattendArgs.push(args[i]);\n        spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            target: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevUntracked = untrackedStart();\n    transactionStart(actionName, scope, false);\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    try {\n        return fn.apply(scope, args);\n    }\n    finally {\n        allowStateChangesEnd(prevAllowStateChanges);\n        transactionEnd(false);\n        untrackedEnd(prevUntracked);\n        if (notifySpy)\n            spyReportEnd({ time: Date.now() - startTime });\n    }\n}\nfunction useStrict(strict) {\n    invariant(globalState.derivationStack.length === 0, \"It is not allowed to set `useStrict` when a derivation is running\");\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res = func();\n    allowStateChangesEnd(prev);\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nfunction propagateAtomReady(atom) {\n    invariant(atom.isDirty, \"atom not dirty\");\n    atom.isDirty = false;\n    propagateReadiness(atom, true);\n}\nvar Atom = (function () {\n    function Atom(name, onBecomeObserved, onBecomeUnobserved) {\n        if (name === void 0) { name = \"Atom@\" + getNextId(); }\n        if (onBecomeObserved === void 0) { onBecomeObserved = noop; }\n        if (onBecomeUnobserved === void 0) { onBecomeUnobserved = noop; }\n        this.name = name;\n        this.onBecomeObserved = onBecomeObserved;\n        this.onBecomeUnobserved = onBecomeUnobserved;\n        this.isDirty = false;\n        this.staleObservers = [];\n        this.observers = [];\n    }\n    Atom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    Atom.prototype.reportChanged = function () {\n        if (!this.isDirty) {\n            this.reportStale();\n            this.reportReady();\n        }\n    };\n    Atom.prototype.reportStale = function () {\n        if (!this.isDirty) {\n            this.isDirty = true;\n            propagateStaleness(this);\n        }\n    };\n    Atom.prototype.reportReady = function () {\n        invariant(this.isDirty, \"atom not dirty\");\n        if (globalState.inTransaction > 0)\n            globalState.changedAtoms.push(this);\n        else {\n            propagateAtomReady(this);\n            runReactions();\n        }\n    };\n    Atom.prototype.toString = function () {\n        return this.name;\n    };\n    return Atom;\n}());\nexports.Atom = Atom;\nvar ComputedValue = (function () {\n    function ComputedValue(derivation, scope, compareStructural, name) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.isLazy = true;\n        this.isComputing = false;\n        this.staleObservers = [];\n        this.observers = [];\n        this.observing = [];\n        this.dependencyChangeCount = 0;\n        this.dependencyStaleCount = 0;\n        this.value = undefined;\n        this.name = name || \"ComputedValue@\" + getNextId();\n    }\n    ComputedValue.prototype.peek = function () {\n        this.isComputing = true;\n        var prevAllowStateChanges = allowStateChangesStart(false);\n        var res = this.derivation.call(this.scope);\n        allowStateChangesEnd(prevAllowStateChanges);\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.onBecomeObserved = function () {\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        for (var i = 0, l = this.observing.length; i < l; i++)\n            removeObserver(this.observing[i], this);\n        this.observing = [];\n        this.isLazy = true;\n        this.value = undefined;\n    };\n    ComputedValue.prototype.onDependenciesReady = function () {\n        var changed = this.trackAndCompute();\n        return changed;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected\", this.derivation);\n        reportObserved(this);\n        if (this.dependencyStaleCount > 0) {\n            return this.peek();\n        }\n        if (this.isLazy) {\n            if (isComputingDerivation()) {\n                this.isLazy = false;\n                this.trackAndCompute();\n            }\n            else {\n                return this.peek();\n            }\n        }\n        return this.value;\n    };\n    ComputedValue.prototype.set = function (_) {\n        throw new Error(\"[ComputedValue '\" + name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this,\n                type: \"compute\",\n                fn: this.derivation,\n                target: this.scope\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = trackDerivedFunction(this, this.peek);\n        return valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener(newValue, prevValue);\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = globalState.derivationStack.length > 0;\n        var observing = unique(this.observing).map(function (dep) { return dep.name; });\n        var observers = unique(this.observers).map(function (dep) { return dep.name; });\n        var runReason = (this.isComputing\n            ? isTracking\n                ? this.observers.length > 0\n                    ? RunReason.INVALIDATED\n                    : RunReason.REQUIRED\n                : RunReason.PEEK\n            : RunReason.NOT_RUNNING);\n        if (runReason === RunReason.REQUIRED) {\n            var requiredBy = globalState.derivationStack[globalState.derivationStack.length - 2];\n            if (requiredBy)\n                observers.push(requiredBy.name);\n        }\n        return ((\"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + runReasonTexts[runReason] + \" \" + ((runReason === RunReason.NOT_RUNNING) && this.dependencyStaleCount > 0 ? \"(a next run is scheduled)\" : \"\") + \"\\n\") +\n            (this.isLazy\n                ?\n                    \" * This computation is suspended (not in use by any reaction) and won't run automatically.\\n\\tDidn't expect this computation to be suspended at this point?\\n\\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\\n\"\n                :\n                    \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + ((this.isComputing && isTracking) ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\tMissing items in this list?\\n\\t  1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n\\t  2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\"));\n    };\n    return ComputedValue;\n}());\nvar RunReason;\n(function (RunReason) {\n    RunReason[RunReason[\"PEEK\"] = 0] = \"PEEK\";\n    RunReason[RunReason[\"INVALIDATED\"] = 1] = \"INVALIDATED\";\n    RunReason[RunReason[\"REQUIRED\"] = 2] = \"REQUIRED\";\n    RunReason[RunReason[\"NOT_RUNNING\"] = 3] = \"NOT_RUNNING\";\n})(RunReason || (RunReason = {}));\nvar runReasonTexts = (_a = {},\n    _a[RunReason.PEEK] = \"[peek] The value of this computed value was requested outside an reaction\",\n    _a[RunReason.INVALIDATED] = \"[invalidated] Some observables used by this computation did change\",\n    _a[RunReason.REQUIRED] = \"[started] This computation is required by another computed value / reaction\",\n    _a[RunReason.NOT_RUNNING] = \"[idle] This compution is currently not running\",\n    _a\n);\nfunction isComputingDerivation() {\n    return globalState.derivationStack.length > 0;\n}\nfunction checkIfStateModificationsAreAllowed() {\n    if (!globalState.allowStateChanges) {\n        invariant(false, globalState.strictMode\n            ? \"It is not allowed to create or change state outside an `action` when MobX is in strict mode. Wrap the current method in `action` if this state change is intended\"\n            : \"It is not allowed to change the state when a computed value or transformer is being evaluated. Use 'autorun' to create reactive functions with side-effects.\");\n    }\n}\nfunction notifyDependencyStale(derivation) {\n    if (++derivation.dependencyStaleCount === 1) {\n        propagateStaleness(derivation);\n    }\n}\nfunction notifyDependencyReady(derivation, dependencyDidChange) {\n    invariant(derivation.dependencyStaleCount > 0, \"unexpected ready notification\");\n    if (dependencyDidChange)\n        derivation.dependencyChangeCount += 1;\n    if (--derivation.dependencyStaleCount === 0) {\n        if (derivation.dependencyChangeCount > 0) {\n            derivation.dependencyChangeCount = 0;\n            var changed = derivation.onDependenciesReady();\n            propagateReadiness(derivation, changed);\n        }\n        else {\n            propagateReadiness(derivation, false);\n        }\n    }\n}\nfunction trackDerivedFunction(derivation, f) {\n    var hasException = true;\n    var prevObserving = derivation.observing;\n    derivation.observing = [];\n    globalState.derivationStack.push(derivation);\n    var prevTracking = globalState.isTracking;\n    globalState.isTracking = true;\n    try {\n        var result = f.call(derivation);\n        hasException = false;\n        bindDependencies(derivation, prevObserving);\n        globalState.isTracking = prevTracking;\n        return result;\n    }\n    finally {\n        if (hasException) {\n            var message = (\"[mobx] An uncaught exception occurred while calculating your computed value, autorun or transformer. Or inside the render() method of an observer based React component. \" +\n                \"These methods should never throw exceptions as MobX will usually not be able to recover from them. \" +\n                (\"Please enable 'Pause on (caught) exceptions' in your debugger to find the root cause. In: '\" + derivation.name + \"'\"));\n            if (isSpyEnabled()) {\n                spyReport({\n                    type: \"error\",\n                    object: this,\n                    message: message\n                });\n            }\n            console.error(message);\n            resetGlobalState();\n        }\n    }\n}\nfunction bindDependencies(derivation, prevObserving) {\n    globalState.derivationStack.length -= 1;\n    var _a = quickDiff(derivation.observing, prevObserving), added = _a[0], removed = _a[1];\n    for (var i = 0, l = added.length; i < l; i++) {\n        var dependency = added[i];\n        invariant(!findCycle(derivation, dependency), \"Cycle detected\", derivation);\n        addObserver(added[i], derivation);\n    }\n    for (var i = 0, l = removed.length; i < l; i++)\n        removeObserver(removed[i], derivation);\n}\nfunction findCycle(needle, node) {\n    if (needle === node)\n        return true;\n    var obs = node.observing;\n    if (obs === undefined)\n        return false;\n    for (var l = obs.length, i = 0; i < l; i++)\n        if (findCycle(needle, obs[i]))\n            return true;\n    return false;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.isTracking;\n    globalState.isTracking = false;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.isTracking = prev;\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\"];\nvar MobXGlobals = (function () {\n    function MobXGlobals() {\n        this.version = 2;\n        this.derivationStack = [];\n        this.mobxGuid = 0;\n        this.inTransaction = 0;\n        this.isTracking = false;\n        this.isRunningReactions = false;\n        this.changedAtoms = [];\n        this.pendingReactions = [];\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n    }\n    return MobXGlobals;\n}());\nvar globalState = (function () {\n    var res = new MobXGlobals();\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack)\n        throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== res.version)\n        throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal)\n        return global.__mobxGlobal;\n    return global.__mobxGlobal = res;\n})();\nfunction registerGlobals() {\n}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals)\n        if (persistentKeys.indexOf(key) === -1)\n            globalState[key] = defaultGlobals[key];\n    globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction addObserver(observable, node) {\n    var obs = observable.observers, l = obs.length;\n    obs[l] = node;\n    if (l === 0)\n        observable.onBecomeObserved();\n}\nfunction removeObserver(observable, node) {\n    var obs = observable.observers, idx = obs.indexOf(node);\n    if (idx !== -1)\n        obs.splice(idx, 1);\n    if (obs.length === 0)\n        observable.onBecomeUnobserved();\n}\nfunction reportObserved(observable) {\n    if (globalState.isTracking === false)\n        return;\n    var derivationStack = globalState.derivationStack;\n    var deps = derivationStack[derivationStack.length - 1].observing;\n    var depslength = deps.length;\n    if (deps[depslength - 1] !== observable && deps[depslength - 2] !== observable)\n        deps[depslength] = observable;\n}\nfunction propagateStaleness(observable) {\n    var os = observable.observers.slice();\n    os.forEach(notifyDependencyStale);\n    observable.staleObservers = observable.staleObservers.concat(os);\n}\nfunction propagateReadiness(observable, valueDidActuallyChange) {\n    observable.staleObservers.splice(0).forEach(function (o) { return notifyDependencyReady(o, valueDidActuallyChange); });\n}\nvar Reaction = (function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) { name = \"Reaction@\" + getNextId(); }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.staleObservers = EMPTY_ARRAY;\n        this.observers = EMPTY_ARRAY;\n        this.observing = [];\n        this.dependencyChangeCount = 0;\n        this.dependencyStaleCount = 0;\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeObserved = function () {\n    };\n    Reaction.prototype.onBecomeUnobserved = function () {\n    };\n    Reaction.prototype.onDependenciesReady = function () {\n        this.schedule();\n        return false;\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this.dependencyStaleCount > 0 || this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            this._isScheduled = false;\n            this._isTrackPending = true;\n            this.onInvalidate();\n            if (this._isTrackPending && isSpyEnabled()) {\n                spyReport({\n                    object: this,\n                    type: \"scheduled-reaction\"\n                });\n            }\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        trackDerivedFunction(this, fn);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            var deps = this.observing.splice(0);\n            for (var i = 0, l = deps.length; i < l; i++)\n                removeObserver(deps[i], this);\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this.observing).map(function (dep) { return dep.name; });\n        return (\"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + ((this._isRunning) ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\tMissing items in this list?\\n\\t  1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n\\t  2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\");\n    };\n    return Reaction;\n}());\nexports.Reaction = Reaction;\nvar MAX_REACTION_ITERATIONS = 100;\nfunction runReactions() {\n    if (globalState.isRunningReactions === true || globalState.inTransaction > 0)\n        return;\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS)\n            throw new Error(\"Reaction doesn't converge to a stable state. Probably there is a cycle in the reactive function: \" + allReactions[0].toString());\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++)\n            remainingReactions[i].runReaction();\n    }\n    globalState.isRunningReactions = false;\n}\nvar spyEnabled = false;\nfunction isSpyEnabled() {\n    return spyEnabled;\n}\nfunction spyReport(event) {\n    if (!spyEnabled)\n        return false;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++)\n        listeners[i](event);\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change)\n        spyReport(objectAssign({}, change, END_EVENT));\n    else\n        spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    spyEnabled = globalState.spyListeners.length > 0;\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1)\n            globalState.spyListeners.splice(idx, 1);\n        spyEnabled = globalState.spyListeners.length > 0;\n    });\n}\nexports.spy = spy;\nfunction trackTransitions(onReport) {\n    deprecated(\"trackTransitions is deprecated. Use mobx.spy instead\");\n    if (typeof onReport === \"boolean\") {\n        deprecated(\"trackTransitions only takes a single callback function. If you are using the mobx-react-devtools, please update them first\");\n        onReport = arguments[1];\n    }\n    if (!onReport) {\n        deprecated(\"trackTransitions without callback has been deprecated and is a no-op now. If you are using the mobx-react-devtools, please update them first\");\n        return function () { };\n    }\n    return spy(onReport);\n}\nfunction transaction(action, thisArg, report) {\n    if (thisArg === void 0) { thisArg = undefined; }\n    if (report === void 0) { report = true; }\n    transactionStart((action.name) || \"anonymous transaction\", thisArg, report);\n    var res = action.call(thisArg);\n    transactionEnd(report);\n    return res;\n}\nexports.transaction = transaction;\nfunction transactionStart(name, thisArg, report) {\n    if (thisArg === void 0) { thisArg = undefined; }\n    if (report === void 0) { report = true; }\n    globalState.inTransaction += 1;\n    if (report && isSpyEnabled()) {\n        spyReportStart({\n            type: \"transaction\",\n            target: thisArg,\n            name: name\n        });\n    }\n}\nfunction transactionEnd(report) {\n    if (report === void 0) { report = true; }\n    if (--globalState.inTransaction === 0) {\n        var values = globalState.changedAtoms.splice(0);\n        for (var i = 0, l = values.length; i < l; i++)\n            propagateAtomReady(values[i]);\n        runReactions();\n    }\n    if (report && isSpyEnabled())\n        spyReportEnd();\n}\nfunction hasInterceptors(interceptable) {\n    return (interceptable.interceptors && interceptable.interceptors.length > 0);\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1)\n            interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    var interceptors = interceptable.interceptors;\n    for (var i = 0, l = interceptors.length; i < l; i++) {\n        change = interceptors[i](change);\n        invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n        if (!change)\n            return null;\n    }\n    untrackedEnd(prevU);\n    return change;\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1)\n            listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    if (Array.isArray(change)) {\n        for (var i = 0, l = listeners.length; i < l; i++)\n            listeners[i].apply(null, change);\n    }\n    else {\n        for (var i = 0, l = listeners.length; i < l; i++)\n            listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nvar ValueMode;\n(function (ValueMode) {\n    ValueMode[ValueMode[\"Recursive\"] = 0] = \"Recursive\";\n    ValueMode[ValueMode[\"Reference\"] = 1] = \"Reference\";\n    ValueMode[ValueMode[\"Structure\"] = 2] = \"Structure\";\n    ValueMode[ValueMode[\"Flat\"] = 3] = \"Flat\";\n})(ValueMode || (ValueMode = {}));\nfunction asReference(value) {\n    return new AsReference(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    return new AsStructure(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    return new AsFlat(value);\n}\nexports.asFlat = asFlat;\nvar AsReference = (function () {\n    function AsReference(value) {\n        this.value = value;\n        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n    }\n    return AsReference;\n}());\nvar AsStructure = (function () {\n    function AsStructure(value) {\n        this.value = value;\n        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n    }\n    return AsStructure;\n}());\nvar AsFlat = (function () {\n    function AsFlat(value) {\n        this.value = value;\n        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n    }\n    return AsFlat;\n}());\nfunction asMap(data, modifierFunc) {\n    return map(data, modifierFunc);\n}\nexports.asMap = asMap;\nfunction getValueModeFromValue(value, defaultMode) {\n    if (value instanceof AsReference)\n        return [ValueMode.Reference, value.value];\n    if (value instanceof AsStructure)\n        return [ValueMode.Structure, value.value];\n    if (value instanceof AsFlat)\n        return [ValueMode.Flat, value.value];\n    return [defaultMode, value];\n}\nfunction getValueModeFromModifierFunc(func) {\n    if (func === asReference)\n        return ValueMode.Reference;\n    else if (func === asStructure)\n        return ValueMode.Structure;\n    else if (func === asFlat)\n        return ValueMode.Flat;\n    invariant(func === undefined, \"Cannot determine value mode from function. Please pass in one of these: mobx.asReference, mobx.asStructure or mobx.asFlat, got: \" + func);\n    return ValueMode.Recursive;\n}\nfunction makeChildObservable(value, parentMode, name) {\n    var childMode;\n    if (isObservable(value))\n        return value;\n    switch (parentMode) {\n        case ValueMode.Reference:\n            return value;\n        case ValueMode.Flat:\n            assertUnwrapped(value, \"Items inside 'asFlat' cannot have modifiers\");\n            childMode = ValueMode.Reference;\n            break;\n        case ValueMode.Structure:\n            assertUnwrapped(value, \"Items inside 'asStructure' cannot have modifiers\");\n            childMode = ValueMode.Structure;\n            break;\n        case ValueMode.Recursive:\n            _a = getValueModeFromValue(value, ValueMode.Recursive), childMode = _a[0], value = _a[1];\n            break;\n        default:\n            invariant(false, \"Illegal State\");\n    }\n    if (Array.isArray(value))\n        return createObservableArray(value, childMode, name);\n    if (isPlainObject(value) && Object.isExtensible(value))\n        return extendObservableHelper(value, value, childMode, name);\n    return value;\n    var _a;\n}\nfunction assertUnwrapped(value, message) {\n    if (value instanceof AsReference || value instanceof AsStructure || value instanceof AsFlat)\n        throw new Error(\"[mobx] asStructure / asReference / asFlat cannot be used here. \" + message);\n}\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = (function () {\n    function StubArray() {\n    }\n    return StubArray;\n}());\nStubArray.prototype = [];\nvar ObservableArrayAdministration = (function () {\n    function ObservableArrayAdministration(name, mode, array, owned) {\n        this.mode = mode;\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new Atom(name || (\"ObservableArray@\" + getNextId()));\n    }\n    ObservableArrayAdministration.prototype.makeReactiveArrayItem = function (value) {\n        assertUnwrapped(value, \"Array values cannot have modifiers\");\n        if (this.mode === ValueMode.Flat || this.mode === ValueMode.Reference)\n            return value;\n        return makeChildObservable(value, this.mode, this.atom.name + \"[..]\");\n    };\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) { fireImmediately = false; }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0)\n            throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength)\n            return;\n        else if (newLength > currentLength)\n            this.spliceWithArray(currentLength, 0, new Array(newLength - currentLength));\n        else\n            this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength)\n            throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta > OBSERVABLE_ARRAY_BUFFER_SIZE)\n            reserveArrayBuffer(oldLength + delta);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        checkIfStateModificationsAreAllowed();\n        var length = this.values.length;\n        if (index === undefined)\n            index = 0;\n        else if (index > length)\n            index = length;\n        else if (index < 0)\n            index = Math.max(0, length + index);\n        if (arguments.length === 1)\n            deleteCount = length - index;\n        else if (deleteCount === undefined || deleteCount === null)\n            deleteCount = 0;\n        else\n            deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined)\n            newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change)\n                return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(this.makeReactiveArrayItem, this);\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        if (deleteCount !== 0 || newItems.length !== 0)\n            this.notifyArraySplice(index, newItems, res);\n        return res;\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy)\n            spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify)\n            notifyListeners(this, change);\n        if (notifySpy)\n            spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy)\n            spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify)\n            notifyListeners(this, change);\n        if (notifySpy)\n            spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}());\nvar ObservableArray = (function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, mode, name, owned) {\n        if (owned === void 0) { owned = false; }\n        _super.call(this);\n        var adm = new ObservableArrayAdministration(name, mode, this, owned);\n        Object.defineProperty(this, \"$mobx\", {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: adm\n        });\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(adm.makeReactiveArrayItem, adm);\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        }\n        else {\n            adm.values = [];\n        }\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) { fireImmediately = false; }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) { fromIndex = 0; }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values, l = items.length;\n        for (var i = fromIndex; i < l; i++)\n            if (predicate.call(thisArg, items[i], i, this))\n                return items[i];\n        return null;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i - 0] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i - 0] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.toString = function () {\n        return \"[mobx.array] \" + Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        return \"[mobx.array] \" + Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray));\nmakeNonEnumerable(ObservableArray.prototype, [\n    \"constructor\",\n    \"observe\",\n    \"clear\",\n    \"replace\",\n    \"toJSON\",\n    \"peek\",\n    \"find\",\n    \"splice\",\n    \"push\",\n    \"pop\",\n    \"shift\",\n    \"unshift\",\n    \"reverse\",\n    \"sort\",\n    \"remove\",\n    \"toString\",\n    \"toLocaleString\"\n]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function () {\n        return this.$mobx.getArrayLength();\n    },\n    set: function (newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\n    \"concat\",\n    \"every\",\n    \"filter\",\n    \"forEach\",\n    \"indexOf\",\n    \"join\",\n    \"lastIndexOf\",\n    \"map\",\n    \"reduce\",\n    \"reduceRight\",\n    \"slice\",\n    \"some\"\n].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    Object.defineProperty(ObservableArray.prototype, funcName, {\n        configurable: false,\n        writable: true,\n        enumerable: false,\n        value: function () {\n            this.$mobx.atom.reportObserved();\n            return baseFunc.apply(this.$mobx.values, arguments);\n        }\n    });\n});\nfunction createArrayBufferItem(index) {\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: false,\n        set: createArraySetter(index),\n        get: createArrayGetter(index)\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        assertUnwrapped(newValue, \"Modifiers cannot be used on array values. For non-reactive array values use makeReactive(asFlat(array)).\");\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed();\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change)\n                    return;\n                newValue = change.newValue;\n            }\n            newValue = adm.makeReactiveArrayItem(newValue);\n            var changed = (adm.mode === ValueMode.Structure) ? !deepEquals(oldValue, newValue) : oldValue !== newValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        }\n        else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        }\n        else\n            throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl && index < impl.values.length) {\n            impl.atom.reportObserved();\n            return impl.values[index];\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++)\n        createArrayBufferItem(index);\n    OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nfunction createObservableArray(initialValues, mode, name) {\n    return new ObservableArray(initialValues, mode, name);\n}\nfunction fastArray(initialValues) {\n    deprecated(\"fastArray is deprecated. Please use `observable(asFlat([]))`\");\n    return createObservableArray(initialValues, ValueMode.Flat, null);\n}\nexports.fastArray = fastArray;\nfunction isObservableArray(thing) {\n    return thing instanceof ObservableArray;\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = (function () {\n    function ObservableMap(initialData, valueModeFunc) {\n        var _this = this;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this.name = \"ObservableMap@\" + getNextId();\n        this._keys = new ObservableArray(null, ValueMode.Reference, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this._valueMode = getValueModeFromModifierFunc(valueModeFunc);\n        if (this._valueMode === ValueMode.Flat)\n            this._valueMode = ValueMode.Reference;\n        allowStateChanges(true, function () {\n            if (isPlainObject(initialData))\n                _this.merge(initialData);\n            else if (Array.isArray(initialData))\n                initialData.forEach(function (_a) {\n                    var key = _a[0], value = _a[1];\n                    return _this.set(key, value);\n                });\n        });\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key))\n            return false;\n        key = \"\" + key;\n        if (this._hasMap[key])\n            return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        assertUnwrapped(value, \"[mobx.map.set] Expected unwrapped value to be inserted to key '\" + key + \"'. If you need to use modifiers pass them as second argument to the constructor\");\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change)\n                return;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        }\n        else {\n            this._addValue(key, value);\n        }\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change)\n                return;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy)\n                spyReportStart(change);\n            transaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            }, undefined, false);\n            if (notify)\n                notifyListeners(this, change);\n            if (notifySpy)\n                spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        }\n        else {\n            entry = this._hasMap[key] = new ObservableValue(value, ValueMode.Reference, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy)\n                spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify)\n                notifyListeners(this, change);\n            if (notifySpy)\n                spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        transaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this._valueMode, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        }, undefined, false);\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy)\n            spyReportStart(change);\n        if (notify)\n            notifyListeners(this, change);\n        if (notifySpy)\n            spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key))\n            return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return this._keys.slice();\n    };\n    ObservableMap.prototype.values = function () {\n        return this.keys().map(this.get, this);\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return this.keys().map(function (key) { return [key, _this.get(key)]; });\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) { return callback.call(thisArg, _this.get(key), key); });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        transaction(function () {\n            if (other instanceof ObservableMap)\n                other.keys().forEach(function (key) { return _this.set(key, other.get(key)); });\n            else\n                Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });\n        }, undefined, false);\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        transaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        }, undefined, false);\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function () {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) { return res[key] = _this.get(key); });\n        return res;\n    };\n    ObservableMap.prototype.toJs = function () {\n        deprecated(\"toJs is deprecated, use toJS instead\");\n        return this.toJS();\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined)\n            return false;\n        if (typeof key !== \"string\" && typeof key !== \"number\" && typeof key !== \"boolean\")\n            return false;\n        return true;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key))\n            throw new Error(\"[mobx.map] Invalid key: '\" + key + \"'\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) { return (key + \": \" + (\"\" + _this.get(key))); }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable maps.\");\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}());\nexports.ObservableMap = ObservableMap;\nfunction map(initialValues, valueModifier) {\n    return new ObservableMap(initialValues, valueModifier);\n}\nexports.map = map;\nfunction isObservableMap(thing) {\n    return thing instanceof ObservableMap;\n}\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = (function () {\n    function ObservableObjectAdministration(target, name, mode) {\n        this.target = target;\n        this.name = name;\n        this.mode = mode;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}());\nfunction asObservableObject(target, name, mode) {\n    if (mode === void 0) { mode = ValueMode.Recursive; }\n    if (isObservableObject(target))\n        return target.$mobx;\n    if (!isPlainObject(target))\n        name = target.constructor.name + \"@\" + getNextId();\n    if (!name)\n        name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name, mode);\n    Object.defineProperty(target, \"$mobx\", {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: adm\n    });\n    return adm;\n}\nfunction setObservableObjectInstanceProperty(adm, propName, value) {\n    if (adm.values[propName])\n        adm.target[propName] = value;\n    else\n        defineObservableProperty(adm, propName, value, true);\n}\nfunction defineObservableProperty(adm, propName, newValue, asInstanceProperty) {\n    if (asInstanceProperty)\n        assertPropertyConfigurable(adm.target, propName);\n    var observable;\n    var name = adm.name + \".\" + propName;\n    var isComputed = true;\n    if (typeof newValue === \"function\" && newValue.length === 0 && !isAction(newValue))\n        observable = new ComputedValue(newValue, adm.target, false, name);\n    else if (newValue instanceof AsStructure && typeof newValue.value === \"function\" && newValue.value.length === 0)\n        observable = new ComputedValue(newValue.value, adm.target, true, name);\n    else {\n        isComputed = false;\n        if (hasInterceptors(adm)) {\n            var change = interceptChange(adm, {\n                object: adm.target,\n                name: propName,\n                type: \"add\",\n                newValue: newValue\n            });\n            if (!change)\n                return;\n            newValue = change.newValue;\n        }\n        observable = new ObservableValue(newValue, adm.mode, name, false);\n        newValue = observable.value;\n    }\n    adm.values[propName] = observable;\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, {\n            configurable: true,\n            enumerable: !isComputed,\n            get: function () {\n                return observable.get();\n            },\n            set: isComputed\n                ? throwingComputedValueSetter\n                : function (v) {\n                    setPropertyValue(this, propName, v);\n                }\n        });\n    }\n    if (!isComputed)\n        notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = instance.$mobx.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change)\n            return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notifyListeners || hasListeners ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy)\n            spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify)\n            notifyListeners(adm, change);\n        if (notifySpy)\n            spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy)\n        spyReportStart(change);\n    if (notify)\n        notifyListeners(adm, change);\n    if (notifySpy)\n        spyReportEnd();\n}\nfunction isObservableObject(thing) {\n    if (typeof thing === \"object\" && thing !== null) {\n        runLazyInitializers(thing);\n        return thing.$mobx instanceof ObservableObjectAdministration;\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = (function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, mode, name, notifySpy) {\n        if (name === void 0) { name = \"ObservableValue@\" + getNextId(); }\n        if (notifySpy === void 0) { notifySpy = true; }\n        _super.call(this, name);\n        this.mode = mode;\n        this.hasUnreportedChange = false;\n        this.value = undefined;\n        var _a = getValueModeFromValue(value, ValueMode.Recursive), childmode = _a[0], unwrappedValue = _a[1];\n        if (this.mode === ValueMode.Recursive)\n            this.mode = childmode;\n        this.value = makeChildObservable(unwrappedValue, this.mode, this.name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: this, newValue: this.value });\n        }\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy)\n                spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        assertUnwrapped(newValue, \"Modifiers cannot be used on non-initial values.\");\n        checkIfStateModificationsAreAllowed();\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change)\n                return UNCHANGED;\n            newValue = change.newValue;\n        }\n        var changed = valueDidChange(this.mode === ValueMode.Structure, this.value, newValue);\n        if (changed)\n            return makeChildObservable(newValue, this.mode, this.name);\n        return UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this))\n            notifyListeners(this, [newValue, oldValue]);\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately)\n            listener(this.value, undefined);\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    return ObservableValue;\n}(Atom));\nfunction getAtom(thing, property) {\n    if (typeof thing === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, \"It is not possible to get index atoms from arrays\");\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            if (property === undefined)\n                return getAtom(thing._keys);\n            var observable_1 = thing._data[property] || thing._hasMap[property];\n            invariant(!!observable_1, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_1;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            invariant(!!property, \"please specify a property\");\n            var observable_2 = thing.$mobx.values[property];\n            invariant(!!observable_2, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        if (thing instanceof Atom || thing instanceof ComputedValue || thing instanceof Reaction) {\n            return thing;\n        }\n    }\n    else if (typeof thing === \"function\") {\n        if (thing.$mobx instanceof Reaction) {\n            return thing.$mobx;\n        }\n    }\n    invariant(false, \"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expection some object\");\n    if (property !== undefined)\n        return getAdministration(getAtom(thing, property));\n    if (thing instanceof Atom || thing instanceof ComputedValue || thing instanceof Reaction)\n        return thing;\n    if (isObservableMap(thing))\n        return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx)\n        return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined)\n        named = getAtom(thing, property);\n    else if (isObservableObject(thing) || isObservableMap(thing))\n        named = getAdministration(thing);\n    else\n        named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, get, set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs) {\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            return {\n                enumerable: enumerable,\n                configurable: true,\n                get: function () {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true)\n                        typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return get.call(this, key);\n                },\n                set: function (v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    }\n                    else {\n                        set.call(this, key, v);\n                    }\n                }\n            };\n        }\n        else {\n            if (!target.hasOwnProperty(\"__mobxLazyInitializers\")) {\n                Object.defineProperty(target, \"__mobxLazyInitializers\", {\n                    writable: false, configurable: false, enumerable: false,\n                    value: (target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice()) || []\n                });\n            }\n            var value_1 = descriptor.value, initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, (initializer_1 ? initializer_1.call(instance) : value_1), customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function () {\n                    if (this.__mobxDidRunLazyInitializers !== true)\n                        runLazyInitializers(this);\n                    return get.call(this, key);\n                },\n                set: function (v) {\n                    if (this.__mobxDidRunLazyInitializers !== true)\n                        runLazyInitializers(this);\n                    set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments))\n                return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            return function (target, key, descriptor) { return classPropertyDecorator(target, key, descriptor, outerArgs); };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!instance.hasOwnProperty(\"__mobxInitializedProps\")) {\n        Object.defineProperty(instance, \"__mobxInitializedProps\", {\n            enumerable: false, configurable: false, writable: true,\n            value: {}\n        });\n    }\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true)\n        return;\n    if (instance.__mobxLazyInitializers) {\n        Object.defineProperty(instance, \"__mobxDidRunLazyInitializers\", {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: true\n        });\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) { return initializer(instance); });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nvar SimpleEventEmitter = (function () {\n    function SimpleEventEmitter() {\n        this.listeners = [];\n        deprecated(\"extras.SimpleEventEmitter is deprecated and will be removed in the next major release\");\n    }\n    SimpleEventEmitter.prototype.emit = function () {\n        var listeners = this.listeners.slice();\n        for (var i = 0, l = listeners.length; i < l; i++)\n            listeners[i].apply(null, arguments);\n    };\n    SimpleEventEmitter.prototype.on = function (listener) {\n        var _this = this;\n        this.listeners.push(listener);\n        return once(function () {\n            var idx = _this.listeners.indexOf(listener);\n            if (idx !== -1)\n                _this.listeners.splice(idx, 1);\n        });\n    };\n    SimpleEventEmitter.prototype.once = function (listener) {\n        var subscription = this.on(function () {\n            subscription();\n            listener.apply(this, arguments);\n        });\n        return subscription;\n    };\n    return SimpleEventEmitter;\n}());\nexports.SimpleEventEmitter = SimpleEventEmitter;\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction invariant(check, message, thing) {\n    if (!check)\n        throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1)\n        return;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked)\n            return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function () { };\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1)\n            res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) { limit = 100; }\n    if (separator === void 0) { separator = \" - \"; }\n    if (!things)\n        return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isPlainObject(value) {\n    return value !== null && typeof value === \"object\" && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source)\n            if (source.hasOwnProperty(key)) {\n                res[key] = source[key];\n            }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    return compareStructural\n        ? !deepEquals(oldValue, newValue)\n        : oldValue !== newValue;\n}\nfunction makeNonEnumerable(object, props) {\n    for (var i = 0; i < props.length; i++) {\n        Object.defineProperty(object, props[i], {\n            configurable: true,\n            writable: true,\n            enumerable: false,\n            value: object[props[i]]\n        });\n    }\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || (descriptor.configurable !== false && descriptor.writable !== false);\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj)\n        res.push(key);\n    return res;\n}\nfunction deepEquals(a, b) {\n    if (a === null && b === null)\n        return true;\n    if (a === undefined && b === undefined)\n        return true;\n    var aIsArray = Array.isArray(a) || isObservableArray(a);\n    if (aIsArray !== (Array.isArray(b) || isObservableArray(b))) {\n        return false;\n    }\n    else if (aIsArray) {\n        if (a.length !== b.length)\n            return false;\n        for (var i = a.length; i >= 0; i--)\n            if (!deepEquals(a[i], b[i]))\n                return false;\n        return true;\n    }\n    else if (typeof a === \"object\" && typeof b === \"object\") {\n        if (a === null || b === null)\n            return false;\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length)\n            return false;\n        for (var prop in a) {\n            if (!(prop in b))\n                return false;\n            if (!deepEquals(a[prop], b[prop]))\n                return false;\n        }\n        return true;\n    }\n    return a === b;\n}\nfunction quickDiff(current, base) {\n    if (!base || !base.length)\n        return [current, []];\n    if (!current || !current.length)\n        return [[], base];\n    var added = [];\n    var removed = [];\n    var currentIndex = 0, currentSearch = 0, currentLength = current.length, currentExhausted = false, baseIndex = 0, baseSearch = 0, baseLength = base.length, isSearching = false, baseExhausted = false;\n    while (!baseExhausted && !currentExhausted) {\n        if (!isSearching) {\n            if (currentIndex < currentLength && baseIndex < baseLength && current[currentIndex] === base[baseIndex]) {\n                currentIndex++;\n                baseIndex++;\n                if (currentIndex === currentLength && baseIndex === baseLength)\n                    return [added, removed];\n                continue;\n            }\n            currentSearch = currentIndex;\n            baseSearch = baseIndex;\n            isSearching = true;\n        }\n        baseSearch += 1;\n        currentSearch += 1;\n        if (baseSearch >= baseLength)\n            baseExhausted = true;\n        if (currentSearch >= currentLength)\n            currentExhausted = true;\n        if (!currentExhausted && current[currentSearch] === base[baseIndex]) {\n            added = added.concat(current.slice(currentIndex, currentSearch));\n            currentIndex = currentSearch + 1;\n            baseIndex++;\n            isSearching = false;\n        }\n        else if (!baseExhausted && base[baseSearch] === current[currentIndex]) {\n            removed = removed.concat(base.slice(baseIndex, baseSearch));\n            baseIndex = baseSearch + 1;\n            currentIndex++;\n            isSearching = false;\n        }\n    }\n    return [\n        added.concat(current.slice(currentIndex)),\n        removed.concat(base.slice(baseIndex))\n    ];\n}\nvar _a;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mobx/lib/mobx.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}